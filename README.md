Go プログラミング言語仕様
==========================

- version 2019/07/31
- https://golang.org/ref/spec のなんちゃって日本語訳
- @ はどうすんべ

訳注
- letter を character を区別するため，letter は英字と訳す
- valid/invalid は有効/無効, legal/illegal は正当/不当と訳す．

# イントロダクション

本文書は Go プログラミング言語のリファレンスマニュアルです．
他の情報源としては，[golang.org](https://golang.org/) を参照されたい．

Go はシステムプログラミングを念頭において設計された，汎用言語です．
強い型付け，ガベージコレクションを持ち，並行プログラミング@ (concurrent programming) を明示的にサポートしています．
プログラムは，
性質が依存関係の効率的な管理を実現する *パッケージ*　で構成される．

文法はコンパクト，かつ，規則的@ (regular) であり，
統合開発環境などの自動ツールによる簡易な解析が可能になります．

# 表記

構文は，Extended Backus-Naur Form（EBNF）によって示します．

```ebnf
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
```

Production は， Term と以下の高い演算子によって構成される式です．
上から，優先順位が低いものから高いものになっています．

```
|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
```

小文字の production 名は，字句トークンを識別するために使用されます．
非末端は CamelCase です．
字句トークンはダブルクオーテーション "" またはバッククォート `` で囲まれます．

形式 `a … b` は，`a` から `b` の文字列の代替に使用します．
3点リーダー `…` は @@@．
文字 `…` (3文字・・・ とは対照的に) は Go言語のトークンではありません．

# ソースコード表現


ソースコードは UTF-8 でエンコードされた Unicode テキストです．
テキストは正規化（canonicalized）されていない．
そのため，単一の・・・@@@

各符号位置@ (code point) は区別され，例えば，大文字と小文字の英字は異なる文字として扱われます．

実装上の制限：
他のツールとの互換性のために，
コンパイラはソースコード上で NUL 文字 (`U+0000`) を許可しない場合があります．

実装上の制限：
他のツールとの互換性のために，
コンパイラは，UTF-8でエンコードされたバイトオーダーマーク (BOM) (`U+FEFF`)
がソースコード上の最初の Unicoe 符号位置であるときに
無視する場合があります．

## 文字 (characters)

以下の term は，特定の Unicode 文字クラス (character class) を示すために使用されます．

```
newline        = /* Unicode 符号位置 (code point) U+000A */ .
unicode_char   = /* 任意の newline を除いた Unicode 符号位置 */ .
unicode_letter = /* "文字 / Letter" に分類される符号位置 */ .
unicode_digit  = /* "数, 10進数 / Number, decimal digit" に分類される符号位置 */ .
```

[The Unicode Standard 8.0](https://www.unicode.org/versions/Unicode8.0.0/) では，
4.5節 "General Category" 節は文字カテゴリの集合を定義しています．
Go は，Lu, Ll, Lt, Lm, Lo  @@@


訳注：

```
Lu = Letter, uppercase
Ll = Letter, lowercase
Lt = Letter, titlecase
Lm = Letter, modifier
Lo = Letter, other
Nd = Number, decimal digit
```

## 英字と数字 (letters and digits)

訳注：letter を character を区別するため，letter は英字と訳す

@@@@


# 字句要素

## コメント

コメントはプログラムのドキュメントとして機能します．
次の２つの形式があります．

1. 行コメント： 文字列 `//` から，行末まで
2. 一般的なコメント： `/*` で始まり，最初の後続の `*/` まで．（訳注：入れ子不可 `/* ABC /* DEF */ GHI */` では GHI はコメントではない）

コメントは，ルーン (@ rune) や文字列リテラル@ 内，または，コメント内では開始できません．
改行を含まない「一般的なコメント」はスペースのように機能します．
他のコメントは改行のように機能します．

## トークン

トークンは Go言語の語彙を形成します．
識別子 (identifier)，
キーワード (keyword)，
演算子 (operator) と句読点 (punctuation)，
リテラル (literal) の 4 つのクラスがあります．
空白 (`U+0020`)，
水平タブ (`U+0009`)，
キャリッジ リターン (`U+000D`)，
改行文字 (ラインフィード，LF)(`U+000A`) から形成される
ホワイトスペースは，
単一に結合するであろうトークンを分離する場合を除いて無視される．
また，改行文字とファイルの末尾はセミコロンを挿入するトリガーになる場合があります．
入力をトークンに分割する間，
次のトークンは有効なトークンを形成する最長の文字シーケンスです．

訳注：`abcde` は `abc`と`de`と分かれることはなく，最長の `abcde`である

## セミコロン


正式な文法では，セミコロン ";" を多くの production の終端として使用する．
Goプログラムでは，次の 2 つの規則を利用して，多くの場合セミコロンを省略できる．

1. 入力をトークンに分割するとき，
行の最後のトークンが以下のとき，その後ろに
セミコロンが自動的に挿入される．
  - 識別子
  - 整数，浮動小数点数，虚数，ルーン，文字列リテラル
  - キーワード break, continue, fallthrough, return
  - 演算子や句読点 ++, --, ), ], }
2. 複雑な文が 1行を専有できるようにするには，閉じカッコ ")", "}" の前では省略できる
[To allow complex statements to occupy a single line, a semicolon may be omitted before a closing ")" or "}".]


慣用的な使用を反映するために，
本ドキュメントのコード例では，これらの規則によりセミコロンを省略する．

## 識別子

識別子 (identify) は，変数 (variable) や型 (type) などのプログラムエンティティ (entity) に名付ける．
識別子は，1 つ以上の英字 (letter) と数字 (digit) の列です．
識別子は，英字から始まらなければなりません．

```
identifier = letter { letter | unicode_digit } .
```

```go
a
_x9
ThisVariableIsExported
αβ
```


いくつかの識別子は事前宣言%%されています．

## キーワード

以下のキーワードは予約されていて，識別子と使用できません．

```
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```

## 演算子と句読点

以下の文字列は識別子 (代入演算子 (assignment operators) を含む) と句読点 (punctuation) です．

```
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=
```

## 整数リテラル

整数リテラル (integer literal) は，
整数定数を表現する数字の列です．
オプションの接頭辞は，
非10進数を表現する．
`0b` と `0B` は2進数，
`0o` と `0O` は8進数，
`0x` と `0X` は16進数を表現する．
単独の `0` は10進数のゼロとみなされる．
16進数では，英字 `a-f` と `A-F` がそれぞれ `10-15` の値を表す．

読みやすさのため，
アンダースコア `_` が接頭辞の後ろ，または，続く数字との間に使用される場合がある．
このアンダースコアは，リテラルの値を変更しない．

```
int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .
decimal_lit    = "0" | ( "1" … "9" ) [ [ "_" ] decimal_digits ] .
binary_lit     = "0" ( "b" | "B" ) [ "_" ] binary_digits .
octal_lit      = "0" [ "o" | "O" ] [ "_" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "_" ] hex_digits .

decimal_digits = decimal_digit { [ "_" ] decimal_digit } .
binary_digits  = binary_digit { [ "_" ] binary_digit } .
octal_digits   = octal_digit { [ "_" ] octal_digit } .
hex_digits     = hex_digit { [ "_" ] hex_digit } .
```

```go
42
4_2
0600
0_600
0o600
0O600       // 2文字目は大文字 `O` である
0xBadFace
0xBad_Face
0x_67_7a_2f_cc_40_c6
170141183460469231731687303715884105727
170_141183_460469_231731_687303_715884_105727

_42         // 整数リテラルではなく，識別子
42_         // 無効: _ は連続する数字を区切る必要がある
4__2        // 無効: _ は一度にひとつのみ
0_xBadFace  // 無効: _ は連続する数字を区切る必要がある
```

## 浮動小数点リテラル

浮動小数点リテラルは，浮動小数点定数の10進数または　16進数表現である．

10進浮動小数リテラルは，整数部 (10進数)，小数点，小数部 (10進数)，
指数部 (`e` または `E` とオプションの符号，10進数）から成る．
整数部と小数部のどちらか一方は省略でき，
小数点と指数部のどちらか一方は省略できる．
指数値 `exp` は仮数 (整数部と小数部）を `10^{exp}` 倍する．


16進数浮動小数リテラルは，接頭 `0x` または `0X`，
整数部 (16進数)，
基数点 (radix point; 訳注 n進数小数点のこと)
小数部 (16進数)，
指数部 (`p` または `P` とオプションの符号，10進数）から成る．
整数部と小数部のどちらか一方は省略できる．
基数点は省略できるが，指数部は必要である．
(この構文は IEEE 754-2008 §5.12.3. で与えられる構文と一致)
指数値 `exp` は仮数 (整数部と小数部）を `2^{exp}` 倍する．

読みやすさのため，
アンダースコア `_` が接頭辞の後ろ，または，続く数字との間に使用される場合がある．
このアンダースコアは，リテラルの値を変更しない．


```
float_lit         = decimal_float_lit | hex_float_lit .

decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
                    decimal_digits decimal_exponent |
                    "." decimal_digits [ decimal_exponent ] .
decimal_exponent  = ( "e" | "E" ) [ "+" | "-" ] decimal_digits .

hex_float_lit     = "0" ( "x" | "X" ) hex_mantissa hex_exponent .
hex_mantissa      = [ "_" ] hex_digits "." [ hex_digits ] |
                    [ "_" ] hex_digits |
                    "." hex_digits .
hex_exponent      = ( "p" | "P" ) [ "+" | "-" ] decimal_digits .
```

```go
0.
72.40
072.40       // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
1_5.         // == 15.0
0.15e+0_2    // == 15.0

0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
0x15e-2      // == 0x15e - 2 (integer subtraction)

0x.p1        // 無効: 仮数部に数字がない
1p-2         // 無効: p 指数には 16進数仮数部が必要
0x1.5e-2     // 無効: 16進化数部は p 指数が必要
1_.5         // 無効: _ は連続する数字を区切る必要がある
1._5         // 無効: _ は連続する数字を区切る必要がある
1.5_e1       // 無効: _ は連続する数字を区切る必要がある
1.5e_1       // 無効: _ は連続する数字を区切る必要がある
1.5e1_       // 無効: _ は連続する数字を区切る必要がある
```

## 虚数リテラル

虚数リテラル (imarinary literal) は複素数定数の虚数部を表す．
虚数リテラルは，整数リテラルまたは浮動小数リテラルと，その後ろに続く小文字英字 `i` から成る．
虚数リテラルの値は，それぞれ，整数リテラルまたは浮動小数リテラルに虚数単位 `i` を掛けた値です．

```
imaginary_lit = (decimal_digits | int_lit | float_lit) "i" .
```

後方互換のため，
虚数リテラルの整数部 (および場合によってはアンダースコア) が
10進数のみで構成される場合は，
`0` で始まっていたとしても 10進数と見なされる．

```go
0i
0123i         // == 123i for backward-compatibility
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // == 0x1p-2 * 1i == 0.25i
```

## ルーンリテラル

ルーンリテラル (rune literal) は
Unicode 符号位置を特定する整数値である
ルーン定数を表現する．
ルーンリテラルは，`'x'` や `'\n'` のようにシングルクォートで囲まれた 1つ以上の文字たちで表現される．
シングルクォート内では，
改行とエスケープされていないシングルクォートを除く任意の文字を使用できる．
シングルクォートで囲まれた1文字は，その文字自身の Unicode 値を表すが，
バックスラッシュで始まる複数の文字たちの場合は，
様々な形式で値をエンコードする．


最もシンプルな形式は，シングルクォートで囲まれた単一の文字を表現します．
Go のソーステキストは UFT-8 でエンコードされた Unicode 文字たちなので，
複数の UTF-8 エンコードバイトは，単一の整数値を表現する場合がある．
例えば，リテラル `'a'` はリテラル `a`, Unicode `U+0061`，値 `0x61` を保持し，
`'ä'` は 2バイト (`0xc3 0xa4`) は
リテラル `a-ウムラウト`, `U+00E4`, 値 `0xe4` を保持する．

いくつかのバックスラッシュエスケープたちにより，
任意の値を
ASCII テキストとしてエンコードできる．
数定数として整数は 4 つの方法で表現できる:
`\x` と正確に 2 桁の 16進数;
`\u` と正確に 4 桁の 16進数;
`\U` と正確に 8 桁の 16進数;
素のバックスラッシュ `\` と正確に 3 桁の 8 進数.
いずれの場合も，リテラルの値は，対応する基数の数字で表される値である．

これらの表現はすべて整数を表すが，
異なる有効範囲をもつ．
8進エスケープは 0 から 255 までの値を表さなければならない．
16進エスケープは，構成からこの条件を満足する．
'\u' と '\U' のエスケープは Unicode 符号位置を表現するので，
一部の値，特に `0x10FFFF` より大きな値とサロゲートハーフたちは不当 (illegal) です．


バックスラッシュの後，特定の一文字のエスケープは特別な値を表します:

```
\a   U+0007 アラート または ベル
\b   U+0008 バックスペース
\f   U+000C form feed
\n   U+000A ラインフィード (line feed) または ニューライン (newline)
\r   U+000D キャリッジリターン (carriage return)
\t   U+0009 水平タブ
\v   U+000b 垂直タブ
\\   U+005c バックスラッシュ
\'   U+0027 シングルクォート (ルーンリテラル内でのみ有効なエスケープ)
\"   U+0022 ダブルクォート (文字列リテラル内でのみ有効なエスケープescape only within string literals)
```

バックスラッシュで始まる他のすべての列は，ルーンリテラルの中では不当 (illegal) です．

```
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
```

```go
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // シングルクォート文字を含むルーンリテラル
'aa'         // illegal: 文字が多すぎる
'\xa'        // illegal: 16進数桁数が少ない
'\0'         // illegal: 8進数の桁数が少ない
'\uDFFF'     // illegal: サロゲートハーフ
'\U00110000' // illegal: 無効な Unicode 符号位置
```

## 文字列リテラル

文字列リテラル (string literal) は，
文字の列を連結して得られる文字列定数を表現する．
生の文字列リテラル (raw string literal) と
解釈された文字列リテラル (interpreted string literal) の
2 つの形式がある．

生の文字列リテラルは
`` `foo` `` のようにバッククォートで囲まれた文字列である．
バッククォート内では，
バッククォートを除く任意の文字を使用できる．
生の文字列リテラルの値は，
バッククォート間の解釈されない（暗黙的に UTF-8 でエンコードされた）
文字で構成される文字列である;
特に，
バックスラッシュには特別な意味はなく，
文字列は改行を含まれる場合がある．
生の文字列リテラル内のキャリッジリターン (`'\r'`) は
生の文字列値から破棄される．

解釈される文字列リテラルは，
`"bar"` のようにダブルクォートで囲まれた文字列である．
ダブルクォート内では，
改行とエスケープされていないダブルクォートを除く任意の文字を使用できる．
ダブルクォート間のテキストは
リテラルの値を形成し，
バックスラッシュエスケープは
ルーンリテラルたち (`\'` は不当，`\"` は正当という点を除く）
であると解釈され， 同様の制限がある．
3桁の 8進数 (`\nnn`) エスケープと 2桁の 16進数 (`\xnn`) エスケープは，
結果の文字列の個々のバイトたちを表す．
すべての他のエスケープは
個々の文字の
(マルチバイト）UTF-8 エンコードを表す．
したがって，
文字列リテラル内の `\377` と `\xFF` は
単一バイトの値 `0xFF = 255` を表し，
`ÿ`, `\u00FF`, `\U000000FF`, `\xc3\xbf` は
文字 `U+00FF` の UTF-8 エンコードの 2 バイト `0xc3 0xbf` を表す．

```ebnf
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
```

```go
`abc`                // "abc" と同じ
`\n
\n`                  // "\\n\n\\n" と同じ
"\n"
"\""                 // `"` と同じ
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // 不当: サロゲートハーフ
"\U00110000"         // 不当: 無効な Unicode 符号位置
```

以下の例は，すべて同じ文字列の表現である.

```
"日本語"                                // UTF-8 入力テキスト
`日本語`                                // 生のリテラルとしての UTF-8 入力テキスト
"\u65e5\u672c\u8a9e"                    // 明示的な Unicode 符号位置
"\U000065e5\U0000672c\U00008a9e"        // 明示的な Unicode 符号位置
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // 明示的な Unicode バイトたち
```

ソースコードが
アクセントと文字を含む結合形式など，
2 つの符号位置として文字を表す場合，
ルーンリテラル（単一の符号位置ではない）に配置すると，
結果はエラーとなり，
文字列リテラルに配置すると，
2 つの符号位置として使用される．


# 定数

ブール定数，ルーン定数，整数定数，浮動小数点整数，
複素数定数，文字列定数がある．
ルーン定数，整数定数，浮動小数点定数，複素数定数を総称して，数値定数と呼ばれる．

定数値は，ルーンリテラル，整数リテラル，浮動小数点リテラル，虚数リテラル，文字列リテラル，
定数を表す識別子，
定数式，
結果が定数となる変換，
任意の値に適用される `unsafe.Sizeof`，
いくつかの表現に適用される `cap`, `len`，
複素数定数に適用される `real`, `imag`，
数値定数に適用される `complex`
のようなビルトイン関数の復帰値
によって表現される．
ブール真偽値は
事前宣言された定数 `true` と `false` によって表現される．
事前宣言された識別子 `iota` は整数定数を示す．

一般に，複素数定数は定数式の形式であり，その節で説明される．

数値定数は任意精度の正確な値を表現し，
オーバーフローしない．
したがって，IEEE-754 の負のゼロ，無限大，非数値 (`NaN`) を示す定数はない．

定数は，型付きでも，型なしでもいい．
リテラル定数，`true`, `false`, `iota`, 型なし定数オペランドを含む定数式は，
型なしです．

定数は，
定数宣言や定数変換によって
明示的に型を指定されるか，
もしくは，
変数宣言や代入で使用するか，
式のオペランドとして暗黙的に指定される．
定数値がそれぞれの型の値として表現されない場合には，
エラーになる．

型なし定数は，
デフォルトの型を持つ．
デフォルトの型は，
例えば，明示的な型がない `i := 0` のような短い変数宣言では，
型付き変数が要求する
コンテキストに暗黙的に変換される．
型なし定数のデフォルトの型は，
真偽値定数，ルーン定数，整数定数，浮動小数点定数，複素数定数，文字列定数はそれぞれ
`bool`, `rune`, `int`, `float64`, `complex128`, `string` である．

実装上の制限：
数値定数は言語では任意精度を持つが，
コンパイラは精度が制限された内部表現を使用して実装する場合がある．
ただし，すべての実装は以下を満たす (MUST):

- 整数定数は少なくとも 256bit を表現する
- 少なくとも 256bit の仮数部と少なくとも  16bit の符号付き 2 進指数を使用して，
複素数定数の部分を含む，浮動小数点定数を表現する
- 整数定数が正確に表現できない場合にはエラーを返す
- 浮動小数定数または複素数定数がオーバーフローのために表現できない場合にはエラーを返す
- 浮動小数定数または複素数定数が精度の制限によって表現できない場合には，最も近い表現可能な定数に丸める

これらの要求は，
リテラル定数と定数式の評価結果の両方に適用される．

# 変数

変数 (variable) は，`値` を保持するための保管場所である．
許容値の集合は，変数の型によって決まる．

変数宣言，または，関数の引数と復帰値のための関数宣言や関数リテラルのシグネチャは，
名前付き変数の保管場所を予約する．
ビルトイン関数 `new` の呼び出しや，
[複合リテラル](#複合リテラル) (composite literal) のアドレスの取得は，
実行時に変数の保管場所が割り当てられる．
そのような無名変数 (anonymous variable) は，
(おそらく暗黙の) ポインター間接 (pointer indirection)
参照される．@@@

配列 (array)，スライス (slice), struct 型の
構造化変数 (structured variable) は，個別にアドレス指定できる要素とフィールドがある．
そのような各要素は変数のように機能する．

変数の静的な型 (または単に型）は，
その宣言で指定された型，
`new` 呼び出しや複合リテラルによって与えられる型，
構造化変数の要素の型である．
インターフェース型の変数もまた，
実行時に代入された値の具体的な型 (型を持たない事前宣言された識別子 `nil` の場合を除く) である
個別の動的な型がある．
動的な型は，
実行中に変化する可能性があるが，
インターフェース変数に割り当てられた値は常に
常に変数の静的な型に割り当て可能 ([assignable](#割り当て可能)) です．


```go
var x interface{}  // x は nil であり，静的な型 interface{} をもつ
var v *T           // v は nil であり，静的な型 *T をもつ
x = 42             // x は 値 42 を持ち，動的な型 int をもつ
x = v              // x 値 (*T)(nil) であり，動的な方 *T をもつ
```

変数の値は，
式に含まれる変数を参照することによって取得される;
それは，変数に代入された最新の値である．
変数に値が割り当てられていない場合，
その値は，その型の[ゼロ値](#ゼロ値)です．


# 型

型 (type) は，
オペレーションの値と，
これらの値に指定されるメソッドの集合を決定する．
型は，
それが一つである場合，
**型名** (type name) を示し，
それが
既存の型から構成される**型リテラル** (type literal) を使って
指定されることがある． @@

```
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
            SliceType | MapType | ChannelType .
```

Go言語は，特定の型名を[事前宣言](#事前宣言) (predeclare)する．
その他は，[型宣言](#型宣言) で導入される．
**複合型**
(配列型，構造体型，ポインター型，関数型，インターフェース型，スライス型，マップ型，チャンネル型)
は型リテラルを使って構築できる．

各型 `T` は基底型 (underlying type) をもつ．
`T` が事前宣言されたブール型，数値型，文字列型の一つであるか，
型リテラルである場合，
対応する基底型は `T` 自身となる．
それ以外の場合，
`T` の基底型は
`T` が[型宣言](#型宣言) で参照する
型の基底型である．

```
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)
```

`A1`, `A2`, `B1`, `B2` の基底型は文字列型である．
`[]B1`, `B3`, `B4` の基底型は `[]B1` である．

## メソッド集合

型は，
型に関連付けられた**メソッド集合** (method set)がある場合がある．
[インターフェース型](#インターフェース型) (interface type) のメソッド集合は，そのインターフェース自身である．
それ以外の型 `T` のメソッド集合は，
レシーバー型 (receiver type) `T` で宣言されたすべてのメソッドで構成される．
ポインタ型 `*T` に対応するメソッド集合は，
レシーバー `*T` もしくは `T` で宣言されたすべてのメソッド集合です．
(つまり，それは `T` のメソッド集合もまた，含む．)
[構造体型](#構造体型) の章で説明しているように，
埋め込みフィールドを含む構造体に
さらなる規則が適用される．
それ以外の型は，空のメソッド集合をもつ．
メソッド集合において，
それぞれのメソッドは
[一意](#識別子の一意性)で，[ブランク](#ブランク識別子)でない
[メソッド名](#インターフェース型)を持たなければならない (MUST)．

ある型のメソッド集合は，
その型が実装するインターフェースと，
その型のレシーバーを用いて呼び出すことができるメソッドによって決定する．

## ブール型

ブール型 (boolean type) は，
事前宣言された定数 `true` と `false` で表記される
ブール真偽値の集合を表現する．
事前宣言されたブール型は `bool` である．
`bool` は，[定義型](#定義型) (defined type) である．


## 数値型

数値型 (numeric type) は整数値の集合または浮動小数点値たちの集合を表現する．
事前宣言されたアーキテクチャに依存しない数値型は以下である．

```
uint8       符号なし 8 ビット整数の集合 (`0`-`255`)
uint16      符号なし 16 ビット整数の集合 (`0`-`65535`)
uint32      符号なし 32 ビット整数の集合 (`0`-`4294967295`)
uint64      符号なし 64 ビット整数の集合 (`0`-`18446744073709551615`)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts @@@ skip

byte        uint8 のエイリアス
rune        int32 のエイリアス
```


`n` ビット整数の値は `n` ビット幅であり，
[2 の補数](https://ja.wikipedia.org/wiki/2%E3%81%AE%E8%A3%9C%E6%95%B0)
を使って表現される．


実装固有のサイズを持つ
事前宣言された数値型の集合もある．

```
uint     32ビットまたは 64ビットのいずれか
int      unit と同じサイズ
uintptr  ポインター値のみ解釈ビットを格納するのに十分大きな符号なし整数
```

移植性の問題を回避するために，
すべての数値型は，[定義型](#定義型)であり，
したがって，
`uint8` の
[エイリアス](#エイリアス宣言) である
`byte` と，
`int32` のエイリアスである
`rune` を除いて区別する．
異なる数値型がひとつの式や代入において混在している場合，
明示的な変換が要求される．
例えば，
あるアーキテクチャにおいては同じ型を有する可能性があるが，
`int32` と `int` が異なる型である

## 文字列型

文字列型 (string type) は文字列値の集合を表現する．
文字列値は，(空を含めた) バイト列である．
バイトの数はその文字列の長さ (length) と呼ばれ，必ず非負である．
文字列は不変 (immutable) である．
つまり，一旦生成されると，文字列の内容を変更することは不可能である．
自薦宣言された文字列型は `string` である．
`string` は，[定義型](#定義型) (defined type) である．

文字列 `s` の長さは，
ビルトイン関数 [`len`](#長さと容量) を使って得られる．
文字列の長さは，
その文字列が定数であれば，
コンパイル時定数 (compile-time constant) である．
文字列のバイトには整数のインデックス `0`-`len(s)-1` でアクセスできる．
`s[i]` が `i` バイト目であり， `&s[i]` が無効であるとい，
アドレスの取得は不当となる．


## 配列型

配列はある要素型 (element type) と呼ばれる単一の型の要素の番号付き列である．
要素の数はその配列の長さと呼ばれ，非負である．

```
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
```

配列の長さは，
配列の型の一部である．
型 `int` の値によって表現可能な非負定数でなければならない．
配列 `a` の長さは，
ビルトイン関数 [`len`](#長さと容量) を使って得られる．
配列の要素は整数のインデックス `0` から `len(a) - 1` でアクセスできる．
配列型はいつでも 1 次元であるが，
多次元型を形成するように構成することもできる．


```
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // [2]([2]([2]float64)) と同じ
```

## スライス型

スライス (slice) は
**基底配列** (underlying array) の連続したセグメントの記述子であり，
その配列の要素に番号付の列でアクセスできる．
スライス型 (slice type) は，その要素型の配列のすべてのスライスの集合を表す．
要素の数はそのスライスの長さ (length) と呼ばれ，必ず非負である．
初期化されていないスライスの値は `nil` である．

```
SliceType = "[" "]" ElementType .
```

スライス `s` の長さは
ビルトイン関数 [`len`](#長さと容量) を使って得られる．
配列と異なり，実行中に変化する．
スライスの要素は，
整数のインデックス `0` から `len(s) - 1` でアクセスできる．
ある要素のスライスでのインデックスは，
基底配列における同じ要素のインデックスよりも小さい場合がある．

スライスは一度初期化されると，
スライスの要素たちを保持する
基礎配列によって関連付けられる．
それゆえ，
スライスは，その基底配列とストレージを共有し，
同じ配列から生成される他のスライスもまた，ストレージを共有する．
対照的に，
異なる配列は，いつでも異なるストレージを表現する．

スライスの基底配列は，
スライスの終端を超えて拡張されうる．
**容量** (capacity) はその拡張量である：
容量は，スライスの長さとそのスライスを超えた配列の長さの和である．
容量を超えた長さのスライスは，
元のスライスから
新しいスライスが元のスライスを[スライスする @@@](#スライス式)ことによって
その容量までの長さのスライスが生成できる．
スライス `a` の容量は，
ビルトイン関数 [`cap(a)`](#長さと容量) を使って得られる．
(訳注：本質的ではないが，本家の typo ではないだろうか. `a` -> `s`)

ある与えられた要素型 `T` の初期化されたスライス値は，
ビルトイン関数 `make` を使って得られる．
`make` はスライス型と，
長さ，および，オプションで容量を指定するパラメータを受け取る．
`make` によって生成されたスライスは
常に復帰されたスライス値を参照する新しい隠し配列が割り当てられる．
つまり，

```
make([]T, length, capacity)
```

を実行すると，
配列を割り当てて，それをスライスして得られるものと同じスライスを生成する．
つまり，以下の 2 つの式は等価である．

```
make([]int, 50, 100)
new([100]int)[0:50]
```

配列のように
スライスはいつも 1 次元である．
しかし，多次元のオブジェクトを構築するために構成することができる．
配列の配列では，内部配列は，構造上，常に同じ長さである．
しかし，スライスのスライス（または，スライスの配列）では，
内部スライスの長さは動的に変化する．
さらに，内部スライスは個別に初期化する必要がある．

## 構造体型

構造体はフィールド (field) と呼ばれる名前付き要素の列である．
各フィールドには名前と型がある．
フィールド名は明示的に指定される (IdentifierList) か，
暗黙的に指定される (EmbeddedField)．
構造体内では，
[ブランク](#ブランク識別子)でないフィールド名は[一意](#識別子の一意性)でなければならない (MUST)．


```
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ "*" ] TypeName .
Tag           = string_lit .
```

```
// 空の構造体
struct {}

// 6 つのフィールドをもつ構造体
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
```

型で宣言されているが，明示的なフィールド名がないフィールドは
**埋め込みフィールド** (embedded field) と呼ばれる．
埋め込みフィールドは，
型名 `T` として指定されるか，
インターフェースでない型名 `*T` へのポインターとして指定されなければならず，
`T` 自身はポインタータイプでない場合がある．
非修飾型名はフィールド名として機能する．

```go
// 型 T1, *T2, P.T3, *P.T4 の型の 4 つの埋め込みフィールドをもつ構造体
struct {
	T1        // フィールド名は T1
	*T2       // フィールド名は T2
	P.T3      // フィールド名は T3
	*P.T4     // フィールド名は T4
	x, y int  // フィールド名は x と y
}
```

次の宣言は，
フィールド名が構造体型内で一意でないため，
不当である:
```go
struct {
	T     // 埋め込みフィールド *T, *P.T と衝突
	*T    // 埋め込みフィールド T, *P.T と衝突
	*P.T  // 埋め込みフィールド T, *T と衝突
}
```

構造体 `x` の埋め込みフィールドの
フィールドや[メソッド](#メソッド宣言) `f` は
もし，`x.f` がフィールドやメソッド `f` を表記される正当な[セレクタ](#セレクタ) である場合，
`x` は昇格された (promoted) と呼ばれる．


昇格フィールド (promoted field) は
構造体の[複合リテラル](#複合リテラル)において
フィールド名として使用できないことを除いて，
構造体の通常のフィールドのように機能する．


構造体型 `S` と
[定義型](#定義型) `T` が与えられたとき，
次のように
昇格されたメソッドは
構造体のメソッド集合に含まれる．

- `S` が埋め込みフィールド `T` を含む場合，`S` と `*S` の[メソッド集合](#メソッド集合)はどちらも
レシーバー `T` と昇格されたメソッドに含まれる．
`*S` のメソッド集合もまた，レシーバー `*T` に
昇格されたメソッドが含まれる．
- `S` が埋め込みフィールド `*T` を含む場合，
`S` と `*S` のメソッド集合はどちらも，レシーバ `T` または `*T` に
昇格されたメソッドが含まれる．


フィールド宣言は，
オプションである文字列リテラル**タグ**に続く場合がある．
これは，対応するフィールド宣言内のすべてのフィールドの属性になる．
空のタグ文字列は，タグがない場合と同値である．
タグは，
[リフレクションインターフェース](#リフレクションインターフェース)
を通して表示され，
構造体の[型同一性 @@@](#型同一性) (type identity) に参加するが，
そうでなければ，無視される．

```go
struct {
	x, y float64 ""  // 空文字列タグは，タグがない場合と似ている
	name string  "タグとして，任意の文字列が許される"
	_    [4]byte "コレハコウゾウタイフィールドデハアリマセン"
}

// TimeStamp プロトコルバッファ (protocol buffer) に対応する構造体
// タグ文字列は，プロトコルバッファのフィールド番号を定義する；
// タグ文字列は，リフレクトパッケージで概説されている規則に従う
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
```

