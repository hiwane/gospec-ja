Go プログラミング言語仕様
==========================

[![Build Status](https://travis-ci.org/hiwane/gospec-ja.svg?branch=master)](https://travis-ci.org/hiwane/gospec-ja)

- The Go Programming Language Specification version 2019/07/31
- https://golang.org/ref/spec のなんちゃって日本語訳
- https://github.com/hiwane/gospec-ja
- @ はこなれていない．どうすんべ

訳注
- valid/invalid は有効/無効, legal/illegal は正当/不当と訳す．
- letter と character を区別するため，letter は英字，character は文字と訳す．
- signed/unsigned 符号付き，符号なし
- source code と source text
- あとでやる：ですます→である
- 表記ユレ：パラメータ，パラメーター，引数

# イントロダクション

本文書は Go プログラミング言語のリファレンスマニュアルです．
他の情報源としては，[golang.org](https://golang.org/) を参照されたい．

Go はシステムプログラミングを念頭において設計された，汎用言語です．
強い型付け，ガベージコレクションを持ち，並行プログラミング@ (concurrent programming) を明示的にサポートしています．
プログラムは，
性質が依存関係の効率的な管理を実現する**パッケージ** (package) で構成される．

文法はコンパクト，かつ，規則的@ (regular) であり，
統合開発環境などの自動ツールによる簡易な解析が可能になります．

# 表記

構文は，Extended Backus-Naur Form（EBNF）によって示します．

```ebnf
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
```

Production は， Term と以下の高い演算子によって構成される式です．
上から，優先順位が低いものから高いものになっています．

```
|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
```

小文字の production 名は，字句トークンを識別するために使用されます．
非末端は CamelCase です．
字句トークンはダブルクオーテーション `""` またはバッククォート `` で囲まれます．

形式 `a … b` は，`a` から `b` の文字列の代替に使用する．
3点リーダー `…` は @@@．
文字 `…` (3文字 `...` とは対照的に) は Go言語のトークンではない．

# ソースコード表現


ソースコードは UTF-8 でエンコードされた Unicode テキストです．
テキストは正規化（canonicalized）されていない．
そのため，単一の・・・@@@

各符号位置@ (code point) は区別され，例えば，大文字と小文字の英字は異なる文字として扱われます．

実装上の制限：
他のツールとの互換性のために，
コンパイラはソースコード上で NUL 文字 (`U+0000`) を許可しない場合があります．

実装上の制限：
他のツールとの互換性のために，
コンパイラは，UTF-8でエンコードされたバイトオーダーマーク (BOM) (`U+FEFF`)
がソースコード上の最初の Unicoe 符号位置であるときに
無視する場合があります．

## 文字 (characters)

以下の項 (term) は，
特定の Unicode 文字クラス (character class) を示すために使用する．

```
newline        = /* Unicode 符号位置 (code point) U+000A */ .
unicode_char   = /* 任意の newline を除いた Unicode 符号位置 */ .
unicode_letter = /* "文字 / Letter" に分類される符号位置 */ .
unicode_digit  = /* "数, 10進数 / Number, decimal digit" に分類される符号位置 */ .
```

[The Unicode Standard 8.0](https://www.unicode.org/versions/Unicode8.0.0/) では，
4.5節 "General Category" 節は文字カテゴリの集合を定義する．
Go は，Letter カテゴリの `Lu`, `Ll`, `Lt`, `Lm`, `Lo` を Unicode 英字として
すべての文字を扱い，
Number カテゴリ `Nd` を Unicode 数字として扱う．


訳注：

```
Lu = Letter, uppercase (英字，大文字 A-Z)
Ll = Letter, lowercase (英字，小文字 a-z)
Lt = Letter, titlecase (英字，タイトル文字)
Lm = Letter, modifier (英字，修飾)
Lo = Letter, other (英字，その他）
Nd = Number, decimal digit (数字，10進数字 0-9)
```

## 英字と数字 (letters and digits)


アンダースコア文字 `_` (`U+005F`) は，
英字 (letter) として考える．

```
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
binary_digit  = "0" | "1" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
```


# 字句要素

## コメント

コメントはプログラムのドキュメントとして機能します．
次の 2 つの形式があります．

1. **行コメント**： 文字列 `//` から，行末まで
2. 一般的な**コメント**： `/*` で始まり，最初の後続の `*/` まで．（訳注：入れ子不可 `/* ABC /* DEF */ GHI */` では GHI はコメントではない）

コメントは，[ルーン](#ルーンリテラル)や[文字列リテラル](#文字列リテラル)内，または，コメント内では開始できません．
改行を含まない「一般的なコメント」はスペースのように機能します．
他のコメントは改行のように機能します．

## トークン

トークンは Go言語の語彙を形成します．
**識別子** (identifier)，
**キーワード** (keyword)，
**演算子** (operator) と**句読点** (punctuation)，
**リテラル** (literal) の 4 つのクラスがあります．
**空白** (`U+0020`)，
水平タブ (`U+0009`)，
キャリッジ リターン (CR, `U+000D`)，
改行文字 (ラインフィード，LF，`U+000A`) から形成される
ホワイトスペースは，
単一に結合するであろうトークンを分離する場合を除いて無視される．
また，改行文字とファイルの末尾は[セミコロン](#セミコロン)を挿入するトリガーになる場合があります．
入力をトークンに分割する間，
次のトークンは有効なトークンを形成する最長の文字シーケンスです．

訳注：`abcde` は `abc`と`de` のように別のトークンとして扱われず，最長の `abcde` である

## セミコロン


正式な文法では，セミコロン `;` を多くの production の終端として使用する．
Goプログラムでは，次の 2 つの規則を利用して，多くの場合セミコロンを省略できる．

1. 入力をトークンに分割するとき，
行の最後のトークンが以下のとき，その後ろに
セミコロンが自動的に挿入される．
  - [識別子](#識別子)
  - [整数リテラル](#整数リテラル)，[浮動小数点リテラル](#浮動小数点リテラル)，
[虚数リテラル](#虚数リテラル)，[ルーンリテラル](#ルーンリテラル)，[文字列リテラル](#文字列リテラル)
  - [キーワード](#キーワード) `break`, `continue`, `fallthrough`, `return`
  - 演算子や句読点 `++`, `--`, `)`, `]`, `}`
2. 複雑な文が 1行を専有できるようにするには，閉じカッコ `)`, `}` の前では省略できる
[To allow complex statements to occupy a single line, a semicolon may be omitted before a closing ")" or "}".]


慣用的な使用を反映するために，
本ドキュメントのコード例では，これらの規則によりセミコロンを省略する．

## 識別子

識別子 (identify) は，変数 (variable) や型 (type) などのプログラムエンティティ (entity) に名付ける．
識別子は，1 つ以上の英字 (letter) と数字 (digit) の列です．
識別子は，英字から始まらなければなりません．

```
identifier = letter { letter | unicode_digit } .
```

```go
a
_x9
ThisVariableIsExported
αβ
```


いくつかの識別子は[事前宣言](#事前宣言された識別子)されています．

## キーワード

以下のキーワードは予約されていて，識別子と使用できません．

```
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```

## 演算子と句読点

以下の文字列は[演算子](#演算子) ([代入演算子](#代入) (assignment operators) を含む) と句読点 (punctuation) です．

```
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=
```

## 整数リテラル

整数リテラル (integer literal) は，
[整数定数](#定数)を表現する数字の列です．
オプションの接頭辞は，
非10進数を表現する．
`0b` と `0B` は2進数，
`0o` と `0O` は8進数，
`0x` と `0X` は16進数を表現する．
単独の `0` は10進数のゼロとみなされる．
16進数では，英字 `a-f` と `A-F` がそれぞれ `10-15` の値を表す．

読みやすさのため，
アンダースコア `_` が接頭辞の後ろ，または，続く数字との間に使用される場合がある．
このアンダースコアは，リテラルの値を変更しない．

```
int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .
decimal_lit    = "0" | ( "1" … "9" ) [ [ "_" ] decimal_digits ] .
binary_lit     = "0" ( "b" | "B" ) [ "_" ] binary_digits .
octal_lit      = "0" [ "o" | "O" ] [ "_" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "_" ] hex_digits .

decimal_digits = decimal_digit { [ "_" ] decimal_digit } .
binary_digits  = binary_digit { [ "_" ] binary_digit } .
octal_digits   = octal_digit { [ "_" ] octal_digit } .
hex_digits     = hex_digit { [ "_" ] hex_digit } .
```

```go
42
4_2
0600
0_600
0o600
0O600       // 2文字目は大文字 `O` である
0xBadFace
0xBad_Face
0x_67_7a_2f_cc_40_c6
170141183460469231731687303715884105727
170_141183_460469_231731_687303_715884_105727

_42         // 整数リテラルではなく，識別子
42_         // 無効: _ は連続する数字を区切る必要がある
4__2        // 無効: _ は一度にひとつのみ
0_xBadFace  // 無効: _ は連続する数字を区切る必要がある
```

## 浮動小数点リテラル

浮動小数点リテラルは，[浮動小数点定数](#定数)の10進数または16進数表現である．

10進浮動小数リテラルは，整数部 (10進数)，小数点，小数部 (10進数)，
指数部 (`e` または `E` とオプションの符号，10進数）から成る．
整数部と小数部のどちらか一方は省略でき，
小数点と指数部のどちらか一方は省略できる．
指数値 `exp` は仮数 (整数部と小数部）を `10^{exp}` 倍する．


16進数浮動小数リテラルは，接頭 `0x` または `0X`，
整数部 (16進数)，
基数点 (radix point; 訳注 n進数小数点のこと)
小数部 (16進数)，
指数部 (`p` または `P` とオプションの符号，10進数）から成る．
整数部と小数部のどちらか一方は省略できる．
基数点は省略できるが，指数部は必要である．
(この構文は IEEE 754-2008 §5.12.3. で与えられる構文と一致)
指数値 `exp` は仮数 (整数部と小数部）を `2^{exp}` 倍する．

読みやすさのため，
アンダースコア `_` が接頭辞の後ろ，または，続く数字との間に使用される場合がある．
このアンダースコアは，リテラルの値を変更しない．


```
float_lit         = decimal_float_lit | hex_float_lit .

decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
                    decimal_digits decimal_exponent |
                    "." decimal_digits [ decimal_exponent ] .
decimal_exponent  = ( "e" | "E" ) [ "+" | "-" ] decimal_digits .

hex_float_lit     = "0" ( "x" | "X" ) hex_mantissa hex_exponent .
hex_mantissa      = [ "_" ] hex_digits "." [ hex_digits ] |
                    [ "_" ] hex_digits |
                    "." hex_digits .
hex_exponent      = ( "p" | "P" ) [ "+" | "-" ] decimal_digits .
```

```go
0.
72.40
072.40       // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
1_5.         // == 15.0
0.15e+0_2    // == 15.0

0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
0x15e-2      // == 0x15e - 2 (integer subtraction)

0x.p1        // 無効: 仮数部に数字がない
1p-2         // 無効: p 指数には 16進数仮数部が必要
0x1.5e-2     // 無効: 16進化数部は p 指数が必要
1_.5         // 無効: _ は連続する数字を区切る必要がある
1._5         // 無効: _ は連続する数字を区切る必要がある
1.5_e1       // 無効: _ は連続する数字を区切る必要がある
1.5e_1       // 無効: _ は連続する数字を区切る必要がある
1.5e1_       // 無効: _ は連続する数字を区切る必要がある
```

## 虚数リテラル

虚数リテラル (imarinary literal) は複素数定数の虚数部を表す．
虚数リテラルは，整数リテラルまたは浮動小数リテラルと，その後ろに続く小文字英字 `i` から成る．
虚数リテラルの値は，それぞれ，整数リテラルまたは浮動小数リテラルに虚数単位 `i` を掛けた値です．

```
imaginary_lit = (decimal_digits | int_lit | float_lit) "i" .
```

後方互換のため，
虚数リテラルの整数部 (および場合によってはアンダースコア) が
10進数のみで構成される場合は，
`0` で始まっていたとしても 10進数と見なされる．

```go
0i
0123i         // == 123i for backward-compatibility
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // == 0x1p-2 * 1i == 0.25i
```

## ルーンリテラル

ルーンリテラル (rune literal) は
Unicode 符号位置を特定する整数値である
ルーン定数を表現する．
ルーンリテラルは，`'x'` や `'\n'` のようにシングルクォートで囲まれた 1つ以上の文字たちで表現される．
シングルクォート内では，
改行とエスケープされていないシングルクォートを除く任意の文字を使用できる．
シングルクォートで囲まれた1文字は，その文字自身の Unicode 値を表すが，
バックスラッシュで始まる複数の文字たちの場合は，
様々な形式で値をエンコードする．


最もシンプルな形式は，シングルクォートで囲まれた単一の文字を表現します．
Go のソーステキストは UFT-8 でエンコードされた Unicode 文字たちなので，
複数の UTF-8 エンコードバイトは，単一の整数値を表現する場合がある．
例えば，リテラル `'a'` はリテラル `a`, Unicode `U+0061`，値 `0x61` を保持し，
`'ä'` は 2バイト (`0xc3 0xa4`) は
リテラル `a-ウムラウト`, `U+00E4`, 値 `0xe4` を保持する．

いくつかのバックスラッシュエスケープたちにより，
任意の値を
ASCII テキストとしてエンコードできる．
数定数として整数は 4 つの方法で表現できる:
`\x` と正確に 2 桁の 16進数;
`\u` と正確に 4 桁の 16進数;
`\U` と正確に 8 桁の 16進数;
素のバックスラッシュ `\` と正確に 3 桁の 8 進数.
いずれの場合も，リテラルの値は，対応する基数の数字で表される値である．

これらの表現はすべて整数を表すが，
異なる有効範囲をもつ．
8進エスケープは 0 から 255 までの値を表さなければならない．
16進エスケープは，構成からこの条件を満足する．
'\u' と '\U' のエスケープは Unicode 符号位置を表現するので，
一部の値，特に `0x10FFFF` より大きな値とサロゲートハーフたちは不当 (illegal) です．


バックスラッシュの後，特定の一文字のエスケープは特別な値を表します:

```
\a   U+0007 アラート または ベル
\b   U+0008 バックスペース
\f   U+000C form feed
\n   U+000A ラインフィード (line feed) または ニューライン (newline)
\r   U+000D キャリッジリターン (carriage return)
\t   U+0009 水平タブ
\v   U+000b 垂直タブ
\\   U+005c バックスラッシュ
\'   U+0027 シングルクォート (ルーンリテラル内でのみ有効なエスケープ)
\"   U+0022 ダブルクォート (文字列リテラル内でのみ有効なエスケープescape only within string literals)
```

バックスラッシュで始まる他のすべての列は，ルーンリテラルの中では不当 (illegal) です．

```
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
```

```go
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // シングルクォート文字を含むルーンリテラル
'aa'         // illegal: 文字が多すぎる
'\xa'        // illegal: 16進数桁数が少ない
'\0'         // illegal: 8進数の桁数が少ない
'\uDFFF'     // illegal: サロゲートハーフ
'\U00110000' // illegal: 無効な Unicode 符号位置
```

## 文字列リテラル

文字列リテラル (string literal) は，
文字の列を連結して得られる文字列定数を表現する．
生の文字列リテラル (raw string literal) と
解釈された文字列リテラル (interpreted string literal) の
2 つの形式がある．

生の文字列リテラルは
`` `foo` `` のようにバッククォートで囲まれた文字列である．
バッククォート内では，
バッククォートを除く任意の文字を使用できる．
生の文字列リテラルの値は，
バッククォート間の解釈されない（暗黙的に UTF-8 でエンコードされた）
文字で構成される文字列である;
特に，
バックスラッシュには特別な意味はなく，
文字列は改行を含まれる場合がある．
生の文字列リテラル内のキャリッジリターン (`'\r'`) は
生の文字列値から破棄される．

解釈される文字列リテラルは，
`"bar"` のようにダブルクォートで囲まれた文字列である．
ダブルクォート内では，
改行とエスケープされていないダブルクォートを除く任意の文字を使用できる．
ダブルクォート間のテキストは
リテラルの値を形成し，
バックスラッシュエスケープは
ルーンリテラルたち (`\'` は不当，`\"` は正当という点を除く）
であると解釈され， 同様の制限がある．
3桁の 8進数 (`\nnn`) エスケープと 2桁の 16進数 (`\xnn`) エスケープは，
結果の文字列の個々のバイトたちを表す．
すべての他のエスケープは
個々の文字の
(マルチバイト）UTF-8 エンコードを表す．
したがって，
文字列リテラル内の `\377` と `\xFF` は
単一バイトの値 `0xFF = 255` を表し，
`ÿ`, `\u00FF`, `\U000000FF`, `\xc3\xbf` は
文字 `U+00FF` の UTF-8 エンコードの 2 バイト `0xc3 0xbf` を表す．

```ebnf
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
```

```go
`abc`                // "abc" と同じ
`\n
\n`                  // "\\n\n\\n" と同じ
"\n"
"\""                 // `"` と同じ
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // 不当: サロゲートハーフ
"\U00110000"         // 不当: 無効な Unicode 符号位置
```

以下の例は，すべて同じ文字列の表現である.

```
"日本語"                                // UTF-8 入力テキスト
`日本語`                                // 生のリテラルとしての UTF-8 入力テキスト
"\u65e5\u672c\u8a9e"                    // 明示的な Unicode 符号位置
"\U000065e5\U0000672c\U00008a9e"        // 明示的な Unicode 符号位置
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // 明示的な Unicode バイトたち
```

ソースコードが
アクセントと文字を含む結合形式など，
2 つの符号位置として文字を表す場合，
ルーンリテラル（単一の符号位置ではない）に配置すると，
結果はエラーとなり，
文字列リテラルに配置すると，
2 つの符号位置として使用される．


# 定数

ブール定数，ルーン定数，整数定数，浮動小数点整数，
複素数定数，文字列定数がある．
ルーン定数，整数定数，浮動小数点定数，複素数定数を総称して，数値定数と呼ばれる．

定数値は，ルーンリテラル，整数リテラル，浮動小数点リテラル，虚数リテラル，文字列リテラル，
定数を表す識別子，
定数式，
結果が定数となる変換，
任意の値に適用される `unsafe.Sizeof`，
いくつかの表現に適用される `cap`, `len`，
複素数定数に適用される `real`, `imag`，
数値定数に適用される `complex`
のようなビルトイン関数の復帰値
によって表現される．
ブール真偽値は
事前宣言された定数 `true` と `false` によって表現される．
事前宣言された識別子 `iota` は整数定数を示す．

一般に，複素数定数は定数式の形式であり，その節で説明される．

数値定数は任意精度の正確な値を表現し，
オーバーフローしない．
したがって，IEEE-754 の負のゼロ，無限大，非数値 (`NaN`) を示す定数はない．

定数は，型付きでも，型なしでもいい．
リテラル定数，`true`, `false`, `iota`, 型なし定数オペランドを含む定数式は，
型なしです．

定数は，
定数宣言や定数変換によって
明示的に型を指定されるか，
もしくは，
変数宣言や代入で使用するか，
式のオペランドとして暗黙的に指定される．
定数値がそれぞれの型の値として表現されない場合には，
エラーになる．

型なし定数は，
デフォルトの型を持つ．
デフォルトの型は，
例えば，明示的な型がない `i := 0` のような短い変数宣言では，
型付き変数が要求する
コンテキストに暗黙的に変換される．
型なし定数のデフォルトの型は，
真偽値定数，ルーン定数，整数定数，浮動小数点定数，複素数定数，文字列定数はそれぞれ
`bool`, `rune`, `int`, `float64`, `complex128`, `string` である．

実装上の制限：
数値定数は言語では任意精度を持つが，
コンパイラは精度が制限された内部表現を使用して実装する場合がある．
ただし，すべての実装は以下を満たす (MUST):

- 整数定数は少なくとも 256bit を表現する
- 少なくとも 256bit の仮数部と少なくとも  16bit の符号付き 2 進指数を使用して，
複素数定数の部分を含む，浮動小数点定数を表現する
- 整数定数が正確に表現できない場合にはエラーを返す
- 浮動小数定数または複素数定数がオーバーフローのために表現できない場合にはエラーを返す
- 浮動小数定数または複素数定数が精度の制限によって表現できない場合には，最も近い表現可能な定数に丸める

これらの要求は，
リテラル定数と定数式の評価結果の両方に適用される．

# 変数

変数 (variable) は，`値` を保持するための保管場所である．
許容値の集合は，変数の**[型](#型)**によって決まる．

[変数宣言](#変数宣言)，または，関数の引数と復帰値のための
[関数宣言](#関数宣言)や[関数リテラル](#関数リテラル)のシグネチャは，
名前付き変数の保管場所を予約する．
ビルトイン関数 [`new`](#割り当て) の呼び出しや，
[複合リテラル](#複合リテラル) (composite literal) のアドレスの取得は，
実行時に変数の保管場所が割り当てられる．
そのような無名変数 (anonymous variable) は，
(おそらく暗黙の) [ポインター間接](#アドレス演算子) (pointer indirection @@@)
参照される．

[配列](#配列型) (array)，[スライス](#配列型) (slice), [構造体型](#構造体型)の
**構造化**変数 (structured variable) は，個別にアドレス指定できる要素とフィールドがある．
そのような各要素は変数のように機能する．

変数の**静的な型** (static type) (または単に**型**）は，
その宣言で指定された型，
`new` 呼び出しや複合リテラルによって与えられる型，
構造化変数の要素の型である．
インターフェース型の変数もまた，
実行時に代入された値の具体的な型 (型を持たない事前宣言された識別子 `nil` の場合を除く) である
個別の**動的な型** (dynamic type) がある．
動的な型は，
実行中に変化する可能性があるが，
インターフェース変数に割り当てられた値は常に
常に変数の静的な型に[代入可能](#代入可能性) (assignable) です．


```go
var x interface{}  // x は nil であり，静的な型 interface{} をもつ
var v *T           // v は nil であり，静的な型 *T をもつ
x = 42             // x は 値 42 を持ち，動的な型 int をもつ
x = v              // x 値 (*T)(nil) であり，動的な方 *T をもつ
```

変数の値は，
[式](#式)に含まれる変数を参照することによって取得される;
それは，変数に[代入された](#代入)最新の値である．
変数に値が割り当てられていない場合，
その値は，その型の[ゼロ値](#ゼロ値)です．


# 型

型 (type) は，
オペレーションの値と，
これらの値に指定されるメソッドの集合を決定する．
型は，
それが一つである場合，
**型名** (type name) を示し，
それが
既存の型から構成される**型リテラル** (type literal) を使って
指定されることがある． @@

```
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
            SliceType | MapType | ChannelType .
```

Go言語は，特定の型名を[事前宣言](#事前宣言された識別子) (predeclare)する．
その他は，[型宣言](#型宣言) で導入される．
**複合型**
(配列型，構造体型，ポインター型，関数型，インターフェース型，スライス型，マップ型，チャンネル型)
は型リテラルを使って構築できる．

各型 `T` は基底型 (underlying type) をもつ．
`T` が事前宣言されたブール型，数値型，文字列型の一つであるか，
型リテラルである場合，
対応する基底型は `T` 自身となる．
それ以外の場合，
`T` の基底型は
`T` が[型宣言](#型宣言) で参照する
型の基底型である．

```
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)
```

`A1`, `A2`, `B1`, `B2` の基底型は文字列型である．
`[]B1`, `B3`, `B4` の基底型は `[]B1` である．

## メソッド集合

型は，
型に関連付けられた**メソッド集合** (method set)がある場合がある．
[インターフェース型](#インターフェース型) (interface type) のメソッド集合は，そのインターフェース自身である．
それ以外の型 `T` のメソッド集合は，
レシーバー型 (receiver type) `T` で宣言されたすべてのメソッドで構成される．
ポインタ型 `*T` に対応するメソッド集合は，
レシーバー `*T` もしくは `T` で宣言されたすべてのメソッド集合です．
(つまり，それは `T` のメソッド集合もまた，含む．)
[構造体型](#構造体型) の章で説明しているように，
埋め込みフィールドを含む構造体に
さらなる規則が適用される．
それ以外の型は，空のメソッド集合をもつ．
メソッド集合において，
それぞれのメソッドは
[一意](#識別子の一意性)で，[ブランク](#ブランク識別子)でない
[メソッド名](#インターフェース型)を持たなければならない (MUST)．

ある型のメソッド集合は，
その型が実装するインターフェースと，
その型のレシーバーを用いて呼び出すことができるメソッドによって決定する．

## ブール型

ブール型 (boolean type) は，
事前宣言された定数 `true` と `false` で表記される
ブール真偽値の集合を表現する．
事前宣言されたブール型は `bool` である．
`bool` は，[定義型](#定義型) (defined type) である．


## 数値型

数値型 (numeric type) は整数値の集合または浮動小数点値たちの集合を表現する．
事前宣言されたアーキテクチャに依存しない数値型は以下である．

```
uint8       符号なし 8 ビット整数の集合 (`0`-`255`)
uint16      符号なし 16 ビット整数の集合 (`0`-`65535`)
uint32      符号なし 32 ビット整数の集合 (`0`-`4294967295`)
uint64      符号なし 64 ビット整数の集合 (`0`-`18446744073709551615`)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts @@@ skip

byte        uint8 のエイリアス
rune        int32 のエイリアス
```


`n` ビット整数の値は `n` ビット幅であり，
[2 の補数](https://ja.wikipedia.org/wiki/2%E3%81%AE%E8%A3%9C%E6%95%B0)
を使って表現される．


実装固有のサイズを持つ
事前宣言された数値型の集合もある．

```
uint     32ビットまたは 64ビットのいずれか
int      unit と同じサイズ
uintptr  ポインター値のみ解釈ビットを格納するのに十分大きな符号なし整数
```

移植性の問題を回避するために，
すべての数値型は，[定義型](#定義型)であり，
したがって，
`uint8` の
[エイリアス](#エイリアス宣言) である
`byte` と，
`int32` のエイリアスである
`rune` を除いて区別する．
異なる数値型がひとつの式や代入において混在している場合，
明示的な変換が要求される．
例えば，
あるアーキテクチャにおいては同じ型を有する可能性があるが，
`int32` と `int` が異なる型である

## 文字列型

文字列型 (string type) は文字列値の集合を表現する．
文字列値は，(空を含めた) バイト列である．
バイトの数はその文字列の長さ (length) と呼ばれ，必ず非負である．
文字列は不変 (immutable) である．
つまり，一旦生成されると，文字列の内容を変更することは不可能である．
自薦宣言された文字列型は `string` である．
`string` は，[定義型](#定義型) (defined type) である．

文字列 `s` の長さは，
ビルトイン関数 [`len`](#長さと容量) を使って得られる．
文字列の長さは，
その文字列が定数であれば，
コンパイル時定数 (compile-time constant) である．
文字列のバイトには整数のインデックス `0`-`len(s)-1` でアクセスできる．
`s[i]` が `i` バイト目であり， `&s[i]` が無効であるとい，
アドレスの取得は不当となる．


## 配列型

配列はある要素型 (element type) と呼ばれる単一の型の要素の番号付き列である．
要素の数はその配列の長さと呼ばれ，非負である．

```
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
```

配列の長さは，
配列の型の一部である．
型 `int` の値によって表現可能な非負定数でなければならない．
配列 `a` の長さは，
ビルトイン関数 [`len`](#長さと容量) を使って得られる．
配列の要素は整数のインデックス `0` から `len(a) - 1` でアクセスできる．
配列型はいつでも 1 次元であるが，
多次元型を形成するように構成することもできる．


```
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // [2]([2]([2]float64)) と同じ
```

## スライス型

スライス (slice) は
**基底配列** (underlying array) の連続したセグメントの記述子であり，
その配列の要素に番号付の列でアクセスできる．
スライス型 (slice type) は，その要素型の配列のすべてのスライスの集合を表す．
要素の数はそのスライスの長さ (length) と呼ばれ，必ず非負である．
初期化されていないスライスの値は `nil` である．

```
SliceType = "[" "]" ElementType .
```

スライス `s` の長さは
ビルトイン関数 [`len`](#長さと容量) を使って得られる．
配列と異なり，実行中に変化する．
スライスの要素は，
整数のインデックス `0` から `len(s) - 1` でアクセスできる．
ある要素のスライスでのインデックスは，
基底配列における同じ要素のインデックスよりも小さい場合がある．

スライスは一度初期化されると，
スライスの要素たちを保持する
基礎配列によって関連付けられる．
それゆえ，
スライスは，その基底配列とストレージを共有し，
同じ配列から生成される他のスライスもまた，ストレージを共有する．
対照的に，
異なる配列は，いつでも異なるストレージを表現する．

スライスの基底配列は，
スライスの終端を超えて拡張されうる．
**容量** (capacity) はその拡張量である：
容量は，スライスの長さとそのスライスを超えた配列の長さの和である．
容量を超えた長さのスライスは，
元のスライスから
新しいスライスが元のスライスを[スライスする @@@](#スライス式)ことによって
その容量までの長さのスライスが生成できる．
スライス `a` の容量は，
ビルトイン関数 [`cap(a)`](#長さと容量) を使って得られる．
(訳注：本質的ではないが，本家の typo ではないだろうか. `a` -> `s`)

ある与えられた要素型 `T` の初期化されたスライス値は，
ビルトイン関数 `make` を使って得られる．
`make` はスライス型と，
長さ，および，オプションで容量を指定するパラメータを受け取る．
`make` によって生成されたスライスは
常に復帰されたスライス値を参照する新しい隠し配列が割り当てられる．
つまり，

```
make([]T, length, capacity)
```

を実行すると，
配列を割り当てて，それをスライスして得られるものと同じスライスを生成する．
つまり，以下の 2 つの式は等価である．

```
make([]int, 50, 100)
new([100]int)[0:50]
```

配列のように
スライスはいつも 1 次元である．
しかし，多次元のオブジェクトを構築するために構成することができる．
配列の配列では，内部配列は，構造上，常に同じ長さである．
しかし，スライスのスライス（または，スライスの配列）では，
内部スライスの長さは動的に変化する．
さらに，内部スライスは個別に初期化する必要がある．

## 構造体型

構造体はフィールド (field) と呼ばれる名前付き要素の列である．
各フィールドには名前と型がある．
フィールド名は明示的に指定される (IdentifierList) か，
暗黙的に指定される (EmbeddedField)．
構造体内では，
[ブランク](#ブランク識別子)でないフィールド名は[一意](#識別子の一意性)でなければならない (MUST)．


```
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ "*" ] TypeName .
Tag           = string_lit .
```

```
// 空の構造体
struct {}

// 6 つのフィールドをもつ構造体
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
```

型で宣言されているが，明示的なフィールド名がないフィールドは
**埋め込みフィールド** (embedded field) と呼ばれる．
埋め込みフィールドは，
型名 `T` として指定されるか，
インターフェースでない型名 `*T` へのポインターとして指定されなければならず，
`T` 自身はポインタータイプでない場合がある．
非修飾型名はフィールド名として機能する．

```go
// 型 T1, *T2, P.T3, *P.T4 の型の 4 つの埋め込みフィールドをもつ構造体
struct {
	T1        // フィールド名は T1
	*T2       // フィールド名は T2
	P.T3      // フィールド名は T3
	*P.T4     // フィールド名は T4
	x, y int  // フィールド名は x と y
}
```

次の宣言は，
フィールド名が構造体型内で一意でないため，
不当である:
```go
struct {
	T     // 埋め込みフィールド *T, *P.T と衝突
	*T    // 埋め込みフィールド T, *P.T と衝突
	*P.T  // 埋め込みフィールド T, *T と衝突
}
```

構造体 `x` の埋め込みフィールドの
フィールドや[メソッド](#メソッド宣言) `f` は
もし，`x.f` がフィールドやメソッド `f` を表記される正当な[セレクタ](#セレクタ) である場合，
`x` は昇格された (promoted) と呼ばれる．


昇格フィールド (promoted field) は
構造体の[複合リテラル](#複合リテラル)において
フィールド名として使用できないことを除いて，
構造体の通常のフィールドのように機能する．


構造体型 `S` と
[定義型](#定義型) `T` が与えられたとき，
次のように
昇格されたメソッドは
構造体のメソッド集合に含まれる．

- `S` が埋め込みフィールド `T` を含む場合，`S` と `*S` の[メソッド集合](#メソッド集合)はどちらも
レシーバー `T` と昇格されたメソッドに含まれる．
`*S` のメソッド集合もまた，レシーバー `*T` に
昇格されたメソッドが含まれる．
- `S` が埋め込みフィールド `*T` を含む場合，
`S` と `*S` のメソッド集合はどちらも，レシーバ `T` または `*T` に
昇格されたメソッドが含まれる．


フィールド宣言は，
オプションである文字列リテラル**タグ**に続く場合がある．
これは，対応するフィールド宣言内のすべてのフィールドの属性になる．
空のタグ文字列は，タグがない場合と同値である．
タグは，
[リフレクションインターフェース](#リフレクションインターフェース)
を通して表示され，
構造体の[型同一性 @@@](#型同一性) (type identity) に参加するが，
そうでなければ，無視される．

```go
struct {
	x, y float64 ""  // 空文字列タグは，タグがない場合と似ている
	name string  "タグとして，任意の文字列が許される"
	_    [4]byte "コレハコウゾウタイフィールドデハアリマセン"
}

// TimeStamp プロトコルバッファ (protocol buffer) に対応する構造体
// タグ文字列は，プロトコルバッファのフィールド番号を定義する；
// タグ文字列は，リフレクトパッケージで概説されている規則に従う
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
```

## ポインター型

ポインター型 (pointer type) は
与えられた型の[変数](#変数)へのすべてのポインターの集合を表し，
ポインターの**基本型** (base type) と呼ばれる．
未初期化のポインターの値は `nil` です．

```
PointerType = "*" BaseType .
BaseType    = Type .
```

```go
*Point
*[4]int
```

## 関数型

関数型 (function type)
は同じパラメーターと復帰型をもつすべての関数の集合を表す．
関数型の未初期化の変数の値は  `nil` です．

```
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
```

パラメータや復帰値のリストでは，
名前 (`IdentifierList`) はすべて存在するか，すべて存在しないかのどちらかである (MUST).
存在する場合，各名前は指定された型の一つのアイテム (パラメータまたは結果）を表し，
シグネチャーにおけるすべての非[ブランク](#ブランク識別子)な名前は
[一意](#識別子の一意性)でなければならない．
存在しない場合，各型は，その型のひとつのアイテムを表す．
正確に 1 つだけの無名の復帰であり，括弧なしの型で書かれる場合を除いて，
パラメータと結果のリストは，いつでも括弧で囲まれる．

関数シグネチャーの最後のパラメーターは，
`...` を接頭辞にもつ型を持つ場合がある．
そのようなパラメータをもつ関数は **可変長引数** (variadic) と呼ばれ，
そのパラメータとして，0個以上の引数として呼び出される．

```go
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
```

# インターフェース型

インターフェース型 (interface type) は
**インターフェース** (interface) と呼ばれる
[メソッド集合](#メソッド集合)を指定する．
インターフェース型の変数は，
インターフェース型の変数は
そのインターフェースの任意のスーパーセットであるメソッド集合の
任意の型の値を格納する．
そのような型は**インターフェースの実装** (implement the interface) という．
インターフェース型の未初期化な変数の値は `nil` である．

```
InterfaceType      = "interface" "{" { ( MethodSpec | InterfaceTypeName ) ";" } "}" .
MethodSpec         = MethodName Signature .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
```

インターフェース型は，
メソッド仕様を介してメソッドを**明示的に**指定するか，
インターフェース型名を介して，
他のインターフェースのメソッドを**埋め込む**ことができる．

```go
// 単純な File インターフェース
interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
```

各明示的に指定されたメソッドの名前は[一意](#識別子の一意性)であり，非[ブランク](#ブランク識別子)でなければならない．


```go
interface {
	String() string
	String() string  // 不当: String は一意でない
	_(x int)         // 不当: メソッドは非ブランク名でなければならない
}
```

複数の型がインターフェースで実装される．
例えば， 2 つの型 `S1` と `S2` が次のメソッド集合を持つ場合，

```go
func (p T) Read(p []byte) (n int, err error)
func (p T) Write(p []byte) (n int, err error)
func (p T) Close() error
```

(ここで，`T` は `S1` または `S2` を表す)
`S1` と `S2` の他のメソッドをもつ，または，共有するかに関係なく，
`File` インターフェースは `S1` と `S2` の両方で実装される．

型は，そのメソッドの部分集合を含むインターフェースを実装するため，
いくつかの異なるインターフェースを実装できる．
例えば，すべての型が**空インターフェース** (empty interface) を実装する．

```go
interface{}
```

同様に，
`Locker` と呼ばれるインターフェースを定義する
[型宣言](#型宣言) で現れる
このインターフェース仕様を考える．

```go
type Locker interface {
	Lock()
	Unlock()
}
```

もし，`S1` と `S2` が次を実装すると

```
func (p T) Lock() { … }
func (p T) Unlock() { … }
```

`S1` と `S2` は `Locker` インターフェースと `File` インターフェースを実装する．

インターフェース `T` は
メソッド仕様の代わりに
(おそらく修飾された) インターフェース型名 `E` を使用できる．
これは，`T` における **埋め込み** (embedding) インターフェース `E` と呼ばれる．
`T` の[メソッド集合](#メソッド集合)は
`T` の明示的に宣言されたメソッド集合と，
`T` の埋め込みインターフェースのメソッド集合の
和集合である．

```go
type Reader interface {
	Read(p []byte) (n int, err error)
	Close() error
}

type Writer interface {
	Write(p []byte) (n int, err error)
	Close() error
}

// ReadWriter のメソッドは Read, Write, Close である
type ReadWriter interface {
	Reader  // `ReadWriter` のメソッド集合は `Reader` のメソッドを含む
	Writer  // `ReadWriter` のメソッド集合は `Writer` のメソッドを含む
}
```

メソッド集合の**和集合**には，
各メソッド集合の
(エクスポート (export) されたおよびされていない)
メソッドが一度だけ含まれ，
[同じ](#識別子の一意性)名前のメソッドは，[同一](#型の一意性)のシグネチャを持たなければならない．

```
type ReadCloser interface {
	Reader  // `ReadWriter` のメソッド集合は `Reader` のメソッドを含む
	Close()  // 不当: `Reader.Close` と `Close` のシグネチャは異なる
}
```

インターフェース型 `T` は
それ自身や `T` が埋め込まれた任意の型を再帰的に埋め込むことはできない．

```go
// 不当: Bad はそれ自身を埋め込めない
type Bad interface {
	Bad
}

// 不当: Bad1 は Bad2 を使ってそれ自身を埋め込むことはできない
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
```

## マップ型

マップ (map) は
要素型 (element type) と呼ばれる要素の型の順序付けられていないグループであり，
キー型 (key type) と呼ばれる別の型の一意キーの集合によってインデックスがつけられる．
未初期化のマップの値は `nil` である．

```
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .
```

比較演算子 `==` と `!=` はキー型のオペランドに定義されなければならない．
したがって，キー型は
関数，マップ，スライスであってはならない．
キー型がインターフェース型である場合，
これらの比較演算子は，
動的にキー値に対して定義されなければならない．
失敗すると，
[ランタイムパニック](#ランタイムパニック) (run-time panic) が発生する．

```
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
```

マップの要素の数は長さと呼ばれる．
マップ `m` に対して，長さはビルトイン関数
ビルトイン関数 [`len`](#長さと容量)を使って得られ，
これは実行中に変化する．
要素は，実行中に [代入](#代入)によって追加し，
[インデックス式](#インデックス式)によって取得できる．
ビルトイン関数 [`delete`](#マップ要素の削除)によって削除できる．

新しい，空のマップ値は，
ビルトイン関数 [`make`](#スライス・マップ・チャンネルの生成)を使って生成でき，
`make` はマップ型とオプションで容量ヒントを引数としてとる．


```
make(map[string]int)
make(map[string]int, 100)
```

初期容量は，そのサイズを制限しない．
マップは，マップに格納されるアイテムの数に合わせて成長する．
`nil` マップは，要素が追加されないことを除いて，からのマップと等価である．


## チャンネル型

チャンネル (channel) は
指定された要素型を[送信](#送信文)と[受信](#受信演算)する値によって通信する
[同時に (concurrently) 実行する関数](#go文)のためのメカニズムを提供する．
未初期化のチャンネルの値は `nil` である．


```
ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType .
```

オプションである `<-` 演算子は
チャンネルの**方向，送信または受信**，を指定する．
もし，方向が指定されなかった場合，
チャンネルは**双方向** (bidirectional) になる．
チャンネルは[代入](#代入)か明示的な[変換](#変換)によって送信のみか受信のみに
制限される場合がある．

```
chan T          // 型 T の値の送受信に使用できる
chan<- float64  // float64 値の送信にのみ使用できる
<-chan int      // int 値の受信にのみ使用できる
```

`<-` 演算子は可能な限り左の `chan` に関連付けられる．

```
chan<- chan int    // chan<- (chan int) と同じ
chan<- <-chan int  // chan<- (<-chan int) と同じ
<-chan <-chan int  // <-chan (<-chan int) と同じ
chan (<-chan int)
```

新しい，初期化されたチャンネル値は，
ビルトイン関数 [`make`](#スライス・マップ・チャンネルの生成) を使って生成でき，
`make` はチャンネル型とオプションで**容量**を
引数としてとる．

```go
make(chan int, 100)
```

容量（要素数）はチャンネル内のバッファサイズを設定する．
容量がゼロまたは存在しない場合，
チャンネルはバッファリングされておらず，
送信者と受信者の両方が準備できたときにのみ，通信は成功する．
それ以外の場合，
チャンネルはバッファリングされており，
バッファがいっぱいでない (送信時）か，
空でない（受信時）場合には，
ブロックせずに通信が成功する．
`nil` チャンネルは通信の準備ができることはない．

チャンネルは
ビルトイン関数 [`close`](#close) を使って閉じられる．
[受信演算子](#受信演算子)の多値代入形式は
チャンネルが閉じられる前に
受信値が送信されたかどうかを報告する．

単一のチャンネルは
さらなる同期なしで任意の数のゴルーチンによって @@@
[送信文](#送信文)，[受信演算](#受信演算)，
ビルトイン関数 [`cap`](#長さと容量) と [`len`](#長さと容量) の呼び出しに使用される．
チャンネルは先入先出 (FIFO: first-in-firs-out) キューとして機能する．
例えば，
あるゴルーチンがチャンネルで値を送信し，
別のゴルーチンがその値を受信すると，
値は送信した順番で受信される．


# 型と値の性質

## 型の一意性

2つの型は同一または異なるものである．

[定義型](#定義型)はいつでも他の型と異なる．
それ以外の場合，
[基底](#型)型リテラルが構造的に同一な場合，
2 つの型は同一である．
つまり，
2 つの型は，同一のリテラル構造を持ち，
対応するコンポーネントたちは，同一の型をもつ．

詳細には，
- 2 つの配列型が，同一の要素型を持ち，同じ配列長である場合，それらは同一である
- 2 つのスライス型が同一の要素型を持つ場合，それらは同一である．
- 2 つの構造体型が同じフィールド列を持ち，対応するフィールドが同じ名前，同一の型，同一のタグをもつ場合，それらは同一である．異なるパッケージの[エクスポート](#エクスポートされた識別子)されていないフィールド名はいつも異なる．
- 2 つのポインター型は，同一の基本型を持つ場合，それらは同一である．
- 2 つの関数型は，
同じ数のパラメータと復帰値をもち，
対応するパラメータと復帰型は同一であり，
どちらの関数も可変長引数であるかそうでないかのどちらかであるとき，
それらは同一である．
パラメータと復帰値の名前は一致する必要はない．
- 2 つのインターフェース型は，
同じ名前と一意関数型をもつメソッドの集合をもつとき，それらは同一である．
異なるパッケージの
[エクスポート](#エクスポートされた識別子)されないメソッド名はいつも異なる．
メソッドの順序は関係ない
- 2 つのマップ型は，一意キー型と要素型が一致するとき，それらは同一である．
- 2 つのチャンネルは，一意要素型と，方向が一致するとき，それらは同一である．


次の宣言を考える．

```go
type (
	A0 = []string
	A1 = A0
	A2 = struct{ a, b int }
	A3 = int
	A4 = func(A3, float64) *A0
	A5 = func(x int, _ float64) *[]string
)

type (
	B0 A0
	B1 []string
	B2 struct{ a, b int }
	B3 struct{ a, c int }
	B4 func(int, float64) *B0
	B5 func(x int, y float64) *A1
)

type	C0 = B0
```

これらは同一である．

```go
A0, A1, and []string
A2 and struct{ a, b int }
A3 and int
A4, func(int, float64) *[]string, and A5

B0 and C0
[]int and []int
struct{ a, b *T5 } and struct{ a, b *T5 }
func(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5
```

`B0` と `B1` は異なる型定義によって生成された新しい型なので，
`B0` と `B1` は異なる;
`B0` は `[]string` と異なるので，
`func(int, float64) *B0` と`func(x int, y float64) *[]string` は異なる．


## 代入可能性

次の条件のうち一つでも満たす場合，
値 `x` は型 `T` の[変数](#変数)に**代入可能** (assignable) である．
(`x` は `T` に代入可能)

- `x` の型は `T` と同一である．
- `x` の型 `V` と `T` は同一の[基底型](#型)をもち，
   `V` と `T` の少なくともひとつは定義型ではない．
- `T` はインターフェース型であり， `x` は `T` を[実装](#インターフェース型)している．
- `x` は双方向のチャンネル値であり，
  `T` はチャンネル型であり，
  `x` の型 `V` と `T` は同一の要素型をもち，
  `V` か `T` の少なくともひとつは定義型ではない．
- `x` は事前宣言された識別子 `nil` であり，`T`
  はポインター型，関数型，スライス型，マップ型，チャンネル型，インターフェース型のいずれかである．
- `x` は型 `T` の値によって[表現可能](#表現可能性)な型なし[定数](#定数)である．

## 表現可能性

次の条件のうち，ひとつの条件を満たすとき，
[定数](#定数) `x` は 型 `T` の値によって表現可能である．

- `x` は `T` によって[決定](#型)される値の集合に属する．
- `T` は浮動小数点型であり，`x` がオーバーフローなしで `T` の精度に丸められる．
   丸めは，IEEE 754 の偶数への丸め (round-to-even) 規則が使用されるが，
   IEEE 負ゼロは更に符号なしゼロに簡単化される．
   定数値は IEEE 負ゼロ, `NaN`, 無限大にはならないことに注意する．
- `T` は複素数型で，`x` の[コンポーネント](#複素数の操作)
`real(x)` と `image(x)` は `T` のコンポーネント型 (`float32` または `float64`)
の値として表現可能である．

```
x                   T           x は T の値によって表現可能である， なぜなら

'a'                 byte        97 は byte 値の集合に属する
97                  rune        ルーンは int32 のエイリアスであり， 97 は 32ビット整数の集合に属する
"foo"               string      "foo" は文字列値の集合に属する
1024                int16       1024 は 16ビット整数の集合に属する
42.0                byte        42 は符号なし 8ビット整数の集合に属する
1e10                uint64      10000000000 は符号なし 64ビット整数の集合に属する
2.718281828459045   float32     2.718281828459045 は float32 値の集合に属する 2.7182817 に丸められる
-1e-1000            float64     -1e-1000 は IEEE -0.0 に丸められ，さらに 0.0 に簡略化される
0i                  int         0 は整数値である
(42 + 0i)           float32     42.0 (0 の虚部をもつ) は float32 値の集合に属する
```

```
x                   T           x は T の値によって表現不可能である， なぜなら

0                   bool        0 はブール値の集合に属しない
'a'                 string      'a' はルーンであり，文字列値の集合に属しない
1024                byte        1024 は符号なし 8ビット整数の集合に属さない
-1                  uint16      -1 は符号なし 16びと整数の集合に属さない
1.1                 int         1.1 は整数値ではない
42i                 float32     (0 + 42i) は float32 値の集合に属さない
1e1000              float64     1e1000 は丸め後に IEEE +Inf にオーバーフローする
```

# ブロック

**ブロック** (block) は，
波括弧 (brace brackets) 内の[宣言と文](#文)の列(空の場合もある)である．

```
Block = "{" StatementList "}" .
StatementList = { Statement ";" } .
```

ソースコード内の明示的なブロックに加えて，
以下の暗黙的なブロックもある．


1. **ユニバースブロック** (universe block) はすべての Go ソースコードを包含する
2. 各[パッケージ](#パッケージ)は，そのパッケージのすべての Go ソースコードに含まれる**パッケージブロック** (package block) をもつ
3. 各ファイルは，そのファイル内のすべての Go ソーステキストを含む**ファイルブロック** (file block) をもつ
4. 各 [`if`文](#if文), [`for`文](#for文), [`switch`文](#switch文)は，それ自身の暗黙的なブロックに含まれると見なされる．
5. [`switch`文](#switch文)と [`select`文](#select文)の各句は暗黙的なブロックとして機能する．

ブロックはネストし，[スコープ](#宣言とスコープ)に影響する．

# 宣言とスコープ

**宣言** (declaration) は，非[ブランク](#ブランク識別子)な識別子を[定数](#定数宣言)，
[型](#型宣言)，
[変数](#変数宣言)，
[関数](#関数宣言)，
[ラベル](#ラベル宣言)，
[パッケージ](#パッケージ宣言)へバインドする (bind)．
プログラム内のすべての識別子は，宣言される必要がある．
同じブロック内で
識別子を 2 回宣言できず，
ファイルとパッケージの両方のブロックで識別子を宣言できない．

[ブランク識別子](#ブランク識別子)は，
宣言内の他の識別子と同じように使用できるが，
バインドされず，したがって，宣言もされない．
パッケージブロックにおいて，
識別子 `init` は
[`init`関数](#パッケージの初期化)の宣言にのみ使用され，
ブランク識別子と同様に，新しいバインドを導入しない．

```
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
```

宣言された識別子の**スコープ** (scope) は，
識別子が
指定された定数，型，変数，関数，ラベル，パッケージを示す
ソーステキストの範囲である．

Go は，[ブロック](#ブロック)を用いて，
字句的にスコープされる．


1. [事前宣言](#事前宣言された識別子)のスコープは，ユニバースブロックである．
2. トップレベルで宣言された
   定数，型，変数，関数 (メソッドは除く）を示す識別子のスコープは，
   パッケージブロックである．
3. インポートされたパッケージのパッケージ名のスコープは，
   インポート宣言を含むファイルのファイルブロックである．
4. メソッドレシーバー，関数パラメーター，復帰変数を示す識別子のスコープは，
   関数本体である．
5. 関数内で宣言された定数と変数識別子のスコープは，
   `ConstSpec` と `VarSpec` (`ShortVarDecl`) の終わりから開始し，
   もっとも内側に含まれるブロックの終端で終了する．
6. 関数内え宣言された型識別子のスコープは，
   `TypeSpec` 内の `identifier` から開始し，
   もっとも内側に含まれるブロックの終端で終了する．

ブロック内で宣言された識別子は，
内部ブロック (inner block)で再宣言できる．
内部ブロックの識別子は，スコープに含まれるが，
内部ブロックの識別子は，
内部宣言によって宣言された実体 (entity) を示す．

[パッケージ句](#パッケージ句) (package clause) は，宣言ではない．
パッケージ名はスコープに現れることはない．
その目的は，同じ[パッケージ](#パッケージ)に属するファイルを特定し，
インポート宣言のデフォルトのパッケージを指定することである．


## ラベルスコープ

ラベル (label) は，
[ラベル文](#ラベル文) (labeled statement) によって宣言され，
[`break` 文](#break文)，
[`continue` 文](#continue文)，
[`goto` 文](#goto文)で使用される．
使用されないラベルを定義することは，不当である．
他の識別子と異なり，
ラベルはブロックスコープではなく，
ラベルでない識別子と衝突しない．
ラベルのスコープはラベルが宣言された関数の本体であり，
ネストされた関数の本体は除く．


## ブランク識別子

**ブランク識別子** (blank identifier) はアンダースコア `_` によって表現される．
ブランク識別子は，通常の (非ブランクな）識別子の代わりに
匿名のプレースホルダー (訳注：一時的に保管するだけの変数）として機能し，
[宣言](#宣言とスコープ)，[オペランド](#オペランド)，[代入](#代入)で特別な意味を持つ．


## 事前宣言された識別子

次の識別子は，[ユニバースブロック](#ブロック) (universe block) で暗黙的に宣言されている．

```
型:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

定数:
	true false iota

ゼロ値:
	nil

関数:
	append cap close complex copy delete imag len
	make new panic print println real recover
```


## エクスポートされた識別子


他のパッケージからのアクセスを許可するために，
識別子は，**エクスポート** (export) できる．
次の 2 つの条件を満足する場合， 識別子はエクスポートされる:

1. 識別子名の最初の文字は，Unicode 大文字 (Unicode クラス "Lu") であり，
2. 識別子は，パッケージブロックで宣言されるか，フィールド名であるか，メソッド名である．

他のすべての識別子はエクスポートされない．

## 識別子の一意性

識別子の集合が与えられたとき，
集合内における他のすべての識別子と**異なる**とき，
識別子は，**一意** (unique) であると呼ぶ．
2 つの識別子が，
「スペルが異なる」か，
「異なる[パッケージ](#パッケージ)に現れ，
[エクスポート](#エクスポートされた識別子)されない」とき，
その識別子たちは異なる．


## 定数宣言

定数宣言 (constant declaration)
識別子のリストに[定数式](#定数式) (constant expression)
のリストの値をバインドする．
識別子の数は，定数式の数と一致しなければならず，
左辺の n 番目の識別子に，
右辺の n 番目の定数式の値がバインドされる．
<a name="ConstSpec"></a>

```
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
```

型が示された場合，
すべての定数は指定された型をとり，
式はその型に[代入可能](#代入可能性)でなければならない．
型が省略された場合，
定数は対応する式の個々の型をとる．
式の値が型なし[定数](#定数)の場合，
宣言された定数は，型なしのままであり，
定数識別子は，定数値を示す．
例えば，
式が浮動小数点リテラルである場合，
定数の小数部がゼロであったとしても
定数識別子は，浮動小数定数を示す．

```go
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // 型なし浮動小数点定数
const (
	size int64 = 1024
	eof        = -1  // 型なし整数定数
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", 型なし整数定数と型なし文字列定数
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
```

丸括弧で囲まれた (parenthesized) `const` 宣言リスト内では，
最初の `ConstSpec` 以外の式リストは省略できる．
このような空の式リストは，
最初の先行する空でない式リストとその型のテキスト置換と等価である．
それゆえに，
式リストの省略は，
前の式リストの繰り返しを繰り返すことと等価である．
識別子の数は，
前のリストにおける式の数と等価である．
このメカニズムは，
[`iota` 定数生成器](#iota) を使うことで，
連続値の容易な宣言を可能とする．

```go
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // この定数はエクスポートされない
)
```

## iota


[定数宣言](#定数宣言)内で，
事前宣言された識別子 `iota` は，
連続した型なし整数[定数](#定数)を表現する．
その値は，
定数宣言におけるそれぞれの [`ConstSpec`](#ConstSpec) ゼロから始まるインデックスである．
関連する定数の集合を作成するために使用できる．

```go
const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 << iota  // a == 1  (iota == 0)
	b = 1 << iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, 使用されない)
	d = 1 << iota  // d == 8  (iota == 3)
)

const (
	u         = iota * 42  // u == 0     (型なし整数定数)
	v float64 = iota * 42  // v == 42.0  (float64 定数)
	w         = iota * 42  // w == 84    (型なし整数定数)
)

const x = iota  // x == 0
const y = iota  // y == 0
```

定義により，
同一の `ConstSpec` 内での
`iota` の複数回の使用は，すべて同じ値をもつ．

```go
const (
	bit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)
	bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)
	_, _                                  //                        (iota == 2, 使用されない)
	bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)
)
```

最後の例は，最後の空でない式リストの[暗黙的な繰り返し](#定数宣言)を利用している．

## 型宣言

型宣言 (type declaration) は，
**型名** (type name) である識別子に[型](#型) (type) をバインドする．
型宣言は，
エイリアス宣言 (alias declarations) と
型定義 (type definitions) の
2 つの形式がある．

```
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec = AliasDecl | TypeDef .
```

### エイリアス宣言

エイリアス宣言 (alias declaration) は
識別子に与えられた型をバインドする．

```
AliasDecl = identifier "=" Type .
```

識別子の[スコープ](#宣言とスコープ)内では，
その識別子は，与えられた型のエイリアスとして機能する．

```go
type (
	nodeList = []*Node  // nodeList と []*Node は同じ型である
	Polar    = polar    // Polar と polar は同じ型を示す
)
```

### 型定義

型定義 (type definition) は
指定された型と
同じ[基底型](#型)と演算をもつ，
新しく，別の型を生成し，
それの新しい型を識別子にバインドする．


```
TypeDef = identifier Type .
```

新しい型は**定義型** (defined type) と呼ばれる．
新しい型は，
生成元となる型を含む，
他のあらゆる型とは，
[異なる](#型の一意性)．

```go
type (
	Point struct{ x, y float64 }  // Point と struct{ x, y float64 } は異なる型である
	polar Point                   // polar と Point は異なる型を示す
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
```

定義型は，それに関連付けられた[メソッド](#メソッド宣言)をもつ場合がある．
定義型は，指定された型にバインドされたメソッドは継承 (inherit) しないが，
インターフェース型，または，
複合型の要素の
[メソッド集合](#メソッド集合)は変更されない．


```go
// Mutex は 2 つのメソッド (Lock, Unlock) をもつデータ型である．
type Mutex struct         { /* Mutex フィールド */ }
func (m *Mutex) Lock()    { /* Lock の実装 */ }
func (m *Mutex) Unlock()  { /* Unlock の実装 */ }

// NewMutex は，Mutex と同じ構成であるが，そのメソッド集合は空である．
type NewMutex Mutex

// *Mutex を基底型とする，PtrMutex のメソッド集合は変更されないが，
// PtrMutex のメソッド集合は空である
type PtrMutex *Mutex

// *PrintableMutex のメソッド集合は埋め込みフィールド Mutex にバインドされた
// 2 つのメソッド Lock と Unlock を含む
type PrintableMutex struct {
	Mutex
}

// MyBlock は Block と同じメソッド集合をもつインターフェース型である
type MyBlock Block
```

型定義は，
ブール型，数値型，文字列型とは異なる型を定義し，
メソッドを関連付けることができる．

```
type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf("GMT%+dh", tz)
}
```

## 変数宣言

変数宣言 (variable declaration) は
1 つ以上の変数を生成し，
対応する識別子を変数にバインドし，
それぞれに型と初期値を与える．

```
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
```

```go
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map lookup; only interested in "found"
```

式のリスト (`ExpressionList`) が与えられたら，
変数は
以下の[代入](#代入)規則に従った式によって初期化される．
そうでなければ，各変数は[ゼロ値](#ゼロ値)で初期化される．

型が指定されると，変数はその型になる．
型が指定されなければ，各変数は代入における対応する初期値の型が与えられる．
その値が型なし定数であれば，
最初に暗黙的に[デフォルト型](#定数)に[変換](#変換)される．
型なしブール値であれば，最初に暗黙的に `bool` 型に変換される．
事前宣言された値 `nil` は，明示的な型なしに初期値として使用することができない．


```go
var d = math.Sin(0.5)  // d は float64
var i = 42             // i は int
var t, ok = x.(T)      // t は T, ok は bool
var n = nil            // 不当
```

実装上の制限：
コンパイラは，
[関数本体](#関数宣言)内で宣言された変数が，
関数内で使用されない場合，
不正とすることがある．


## 簡潔な変数宣言

**簡潔な変数宣言** (short variable declaration) は次の文法を使用する．

```
ShortVarDecl = IdentifierList ":=" ExpressionList .
```

これは，初期値があるが型がない通常の[変数宣言](#変数宣言)の省略形である．

```
"var" IdentifierList = ExpressionList .
```

```go
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w, _ := os.Pipe()  // os.Pipe() は Files の接続ペア(r, w)と error を返す
_, y, _ := coord(p)   // coord() は 3 つの値を返す; しかし， y 軸にしか興味がない
```


通常の変数宣言とは異なり，
簡潔な変数宣言では，
同じブロック内
(または，そのブロックが関数本体であればパラメーターリスト)
で前に宣言された同じ型の変数
そして，少なくとも 1 つの非[ブランク](#ブランク識別子)な変数が新しい場合，
変数を**再宣言** (redeclare) できる．
結果として，再宣言は多値の簡潔な変数宣言においてのみ使用される．
再宣言では新しい変数は導入されず，
新しい値が元の変数に代入される．


```go
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // オフセットを再宣言する
a, a := 1, 2                              // 不正: a が他の場所で宣言されている場合，a の二重宣言または新規変数なし
```

簡潔な変数宣言は，関数内でのみ現れる．
[`if`文](#if文)，
[`for`文](#for文)，
[`switch`文](#switch文)の初期化のように
ローカル一時変数のの宣言にしようできる．

## 関数宣言

関数宣言 (function declaration) は
**関数名** (function name) である識別子に，
関数をバインドする．

```
FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
FunctionName = identifier .
FunctionBody = Block .
```

関数の[シグネチャー](#関数型)が復帰パラメータたちを宣言する場合，
関数本体の文のリストは，
[終端文](#終端文) (terminating statement) で終了しなければならない．


```go
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// 無効: return 文がない
}
```

関数は，その本体なしで宣言される場合がある．
そのような宣言は，
アセンブリルーチン (assembly routine) のように
Go の外で実装された関数のシグネチャーを提供する．

```go
func min(x int, y int) int {
	if x < y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // 外部で実装される
```


## メソッド宣言

メソッド (method) は **レシーバー** (receiver) をもつ関数である．
メソッド宣言 (method declaration) は
**メソッド名** (method name) である識別子に，メソッドをバインドし，
レシーバーの**基本型** (base type) にメソッドを関連付ける．

```
MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
Receiver   = Parameters .
```

レシーバーは，メソッド名の前にある追加のパラメータ節で指定される．
そのパラメータ節は，ひとつの不可変数引数で，そのレシーバーを宣言する．
その型は，[定義](#定義型)型 `T`，または，定義型 `T`
へのポインターでなければならない．
`T` はレシーバー**基本型** (base type)と呼ばれる．
レシーバー基本型は，ポインター型またはインターフェース型にすることはできず，
メソッドとして，同じパッケージ内で定義されなければならない．
そのメソッドはレシーバー基本型に**バインド** (bind) されると言い，
メソッド名は，型 `T` または型 `*T` の[セレクタ](#セレクタ)内でのみ表示される．

非[ブランク](#ブランク識別子)なレシーバー識別子は，
メソッドシグネチャー内で，[一意](#識別子の一意性)でなければならない．
レシーバーの値がメソッドの本体内で参照されないなら，
その識別子は宣言において省略できる．
一般に，関数のメソッドとパラメータにも同じことが当てはまる．

基本型の場合，
基本型にバイドされるメソッドの非ブランク名は一意でなければならない．
基本型が[構造体型](#構造体型)であるなら，
非ブランクなメソッドとフィールド名は別でなければならない．

定義型 `Point` が与えられたとき，宣言

```go
func (p *Point) Length() float64 {
	return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
	p.x *= factor
	p.y *= factor
}
```

は，(レシーバー型 `*Point` の) メソッド `Length` と `Scale` を
基本型 `Point` にバインドする．

メソッドの型は，
最初の引数をそのレシーバーとする関数の型である．
例えば，メソッド `Scale` は次の型をもつ．

```go
func(p *Point, factor float64)
```

しかしながら，この方法で宣言された関数はメソッドではない．

# 式

式 (expression) は．
演算子と関数をオペランドへの適用によって値の計算を指定する．

## オペランド

オペランド (operand) は式における基本値を示す．
オペランドは，
リテラル， または，
[定数](#定数宣言)，
[変数](#変数宣言)，
[関数](#関数宣言)を示す
(場合によっては[修飾された](#修飾識別子))
非[ブランク](#ブランク識別子)な識別子，または，
丸括弧で囲まれた式である．

[ブランク](#ブランク識別子)は
[代入](#代入)の左辺においてのみ
オペランドとして現れる．

```
Operand     = Literal | OperandName | "(" Expression ")" .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent .
```

## 修飾識別子

修飾識別子 (qualified identifier) は
パッケージ名を前頭において修飾された識別子である．
パッケージ名と識別子はどちらも
[ブランク](#ブランク識別子)にできない．

```
QualifiedIdent = PackageName "." identifier .
```

修飾識別子は，
[インポート](#インポート宣言)されなければならない，
別のパッケージの識別子にアクセスする．
識別子は，[エクスポート](#エクスポートされた識別子)されており，
そのパッケージの[パッケージブロック](#ブロック)で宣言されていなければならない．

```
math.Sin	// パッケージ math の Sin 関数を示す
```

## 複合リテラル

複合リテラル (composite literal, `CompositeLit`) は，
構造体，配列，スライス，マップの値を構築し，
複合リテラルが評価されるたびに新しい値を生成する．
複合リテラルは，
リテラルの型 `LiteralType` と，
波括弧で囲まれた要素のリスト `LiteralValue` から成る．
各要素は，オプションとして対応するキー `Key` を要素の前に置くことがある．

```
CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = KeyedElement { "," KeyedElement } .
KeyedElement  = [ Key ":" ] Element .
Key           = FieldName | Expression | LiteralValue .
FieldName     = identifier .
Element       = Expression | LiteralValue .
```

`LiteralType` の基底型は，
構造体型，配列型，スライス型，マップ型でなければならない
(型が `TypeName` として与えられた場合を除いて，文法はこの制約を強制する)．
要素とキーの型は，
リテラル型のそれぞれのフィールド型，要素型，キー型に
[代入可能](#代入可能性)でなければならない．
さらなる変換はない．
キーは，
構造体のフィールド名，
配列リテラルとスライスリテラルのインデックス，
マップリテラルのキーとして解釈される．
マップリテラルの場合，
すべての要素はキーと持たなければならない．
同じフィールド名，または，定数キー値をもつ複数の要素を指定した場合，エラーになる．
非定数マップキーの場合は，[評価順序](#評価順序)節を参照されたい．


構造体リテラルの場合，以下の規則が適用される：

- キーは，構造体型内で宣言されたフィールド名でなければならない
- キーを全く含まないは要素リスト `ElementList` は，
フィールドが宣言された順序で
  各構造体フィールドに対する要素がリストされなければならない．
- ある要素がキーをもつならば，すべて要素がキーをもたなければならない．
- キーを含む要素リストは， 構造体フィールドの要素が必要ない．
省略されたフィールドにはそのフィールドのゼロ値を取得する．
- リテラルは要素リストを省略してもいい．そのようなリテラルは，その型のゼロ値が評価される．
- 異なるパッケージに属する構造体のエクスポートされないフィールドの要素を指定するとエラーになる．


次の宣言が与えられたとき，

```go
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
```

次のように書いてもいい．

```go
origin := Point3D{}                            // Point3D のゼロ値
line := Line{origin, Point3D{y: -4, z: 12.3}}  // line.q.x にゼロ値
```

配列リテラルとスライスリテラルの場合，以下の規則が適用される：

- 各要素は，配列の位置を示す整数インデックスが関連付けられている
- キーをもつ要素は，そのインデックスとしてそのキーを使用する．
キーは `int` 型の値で[表される](#表現可能性)非負定数でなければならない．
- キーを持たない要素は，その前の要素のインデックスに 1 を加えた値を使用する．
最初の要素がキーを持たなければ，そのインデックスは 0 である．


複合リテラルの[アドレスを取得](#アドレス演算)すると，
リテラル値で初期化された一意の[変数](#変数)へのポインターが生成される．


```go
var pointer *Point3D = &Point3D{y: 1000}
```

スライス型とマップ型の[ゼロ値](#ゼロ値)は同じ型の空の値に初期化されたものを同じではないことに注意されたい．
したがって，
空のスライスの複合リテラルのアドレス，または，
空のマップの複合リテラルのアドレスを取得することは，
[`new`](#割り当て)
によって新しいスライス値やマップ値を割り当てることとは同じ効果ではない．


```go
p1 := &[]int{}    // p1 []int{} 値の空のスライスで長さ 0 のスライスをポイントする
p2 := new([]int)  // p2 は nil 値をもつ未初期化で長さ 0 のスライスをポイントする
```

配列リテラルの長さはリテラル型において指定された長さである．
長さよりも少ない要素がリテラルで指定された場合，
不足している要素には，
配列の要素型に対するゼロ値が設定される．
配列のインデックスの範囲外となるインデックス値を要素に指定すると，
エラーになる．
表記 `...` は配列の長さとして，
要素のインデックスの最大値に 1 を加えたものが指定する．


```go
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
```

スライスリテラルは，
基底配列リテラル全体を記述する．
したがって，スライスリテラルの長さと容量は
要素のインデックスの最大値に 1 を加えたものとなる．
スライスリテラルは，次の形式をもつ．

```go
[]T{x1, x2, … xn}
```

配列に適用されるスライス操作の省略形は以下である．

```go
tmp := [n]T{x1, x2, … xn}
tmp[0 : n]
```

`T` を配列型，スライス型，または，マップ型とする．
`T` の複合リテラル内で，
それ自身が複合リテラルであるような要素やマップキーは，
もし，それが `T` の要素型，またはキー型と同一であるなら，
それぞれのリテラル型を削除できる．
同様に，
複合リテラルのアドレスであるような要素やキーは，
要素型，またはキー型が `*T` であるとき，
`&T` を削除できる．


```go
[...]Point{{1.5, -3.5}, {0, 0}}     // [...]Point{Point{1.5, -3.5}, Point{0, 0}} と同じ
[][]int{{1, 2, 3}, {4, 5}}          // [][]int{[]int{1, 2, 3}, []int{4, 5}} と同じ
[][]Point{{{0, 1}, {1, 2}}}         // [][]Point{[]Point{Point{0, 1}, Point{1, 2}}} と同じ
map[string]Point{"orig": {0, 0}}    // map[string]Point{"orig": Point{0, 0}} と同じ
map[Point]string{{0, 0}: "orig"}    // map[Point]string{Point{0, 0}: "orig"} と同じ

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // [2]*Point{&Point{1.5, -3.5}, &Point{}} と同じ
[2]PPoint{{1.5, -3.5}, {}}          // [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})} と同じ
```

`TypeName` 形式の `LiteralType` を用いた複合リテラルが，
キーワードと `if`文, `for`文, `switch`文の
ブロックの開き波括弧 `{` の間にオペランドとして現れ，かつ，
複合リテラルが，丸括弧 `()`，角括弧 `[]`，波括弧 `{}`で囲まれていないとき，
構文解析における曖昧性が発生する．
この稀なケースでは，
リテラルの開き波括弧 `{` が文のブロックを導入するものとして，
誤って解析される．
この曖昧性を解決するために，
複合リテラルは，丸括弧の中に表示する必要がある．


```go
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
```

有効な配列リテラル，スライスリテラル，マップリテラルの例：

```go
// 素数のリスト
primes := []int{2, 3, 5, 7, 9, 2147483647}

// ch が vowel であれば vowels[ch] は true である
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// 配列 [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// 平均律スケールの周波数 (Hz) (A4 = 440Hz)
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
```


## 関数リテラル

関数リテラル (function literal) は
無名関数を表現する．

```
FunctionLit = "func" Signature FunctionBody .
```

```go
func(a, b int, z float64) bool { return a*b < int(z) }
```

関数はリテラルは，変数に代入されるか，直接呼び出される．

```go
f := func(x, y int) int { return x + y }
func(ch chan int) { ch <- ACK }(replyChan)
```

関数リテラルは**クロージャー** (closure) である．
関数リテラルは，周囲の関数で定義された変数を参照する場合がある．
これらの変数は，周囲の関数と関数リテラルで共有され，
アクセス可能である限り，生存する (survive)．

## 一次式

一次式 (primary expression) は，単項式 (unary expression) と
二項式 (binary expression) のオペランドである．

```
PrimaryExpr =
	Operand |
	Conversion |
	MethodExpr |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Slice |
	PrimaryExpr TypeAssertion |
	PrimaryExpr Arguments .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
                 "[" [ Expression ] ":" Expression ":" Expression "]" .
TypeAssertion  = "." "(" Type ")" .
Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
```

```go
x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
f.p[i].x()
```

## セレクタ

[パッケージ名](#パッケージ句)ではない
[一次式](#一次式) `x` に対して，
**セレクタ式** (selector expression)

```go
x.f
```

は，値 `x` (または，`*x`; 下記参照) のフィールド `f`，またはメソッド `f` を示す．
識別子 `f` は (フィールド，またはメソッド) **セレクタ** (selector) と呼ばれ，
[ブランク識別子](#ブランク識別子)であってはならない．
セレクタ式の型は `f` の型である．
`x` がパッケージ名の場合は，[修飾識別子](#修飾識別子)を参照されたい．

セレクタ `f` は
型 `T` のフィールド `f` またはメソッド `f` を示す場合と，
`T` のネストされた[埋め込みフィールド](#構造体型)のフィールド `f` かメソッド `f`
を参照する場合がある．
`f` に到達するためにたどる埋め込みフィールドの数を
`T` における `f` の**深さ** (depth) と呼ばれる．
`T で宣言されたフィールド `f` またはメソッド `f` の深さはゼロである．
`T` の埋め込みフィールド `A` において宣言された
フィールド `f` またはメソッド `f` の深さは，
`A` における `f` の深さに 1 加えたものである．

以下のルールがセレクタに適用される．

1. `T` がポインター型やインターフェース型 でないとするとき，
  型 `T` または型 `*T` の値 `x` に対して，
  `x.f` は `f` が存在するとき，
  `T` の深さがもっとも浅いフィールド，またはメソッドを示す．
  深さが最も浅い `f` がちょうど一つだけ存在しない場合，
  セレクタ表現は不当である．
2. `I` がインターフェース型であるとき，`I` の値 `x` に対して，
  `x.f` は `x` の動的な値の名前 `f` をもつ実際のメソッドを示す．
  名前 `f` のメソッドが
  `I` の[メソッド集合](#メソッド集合)に存在しない場合，
  セレクタ表現は不当である．
3. 例外として，
   `x` の型が[定義された](#型定義)ポインター型であり，
   `(*x).f` が
   フィールドを示す (しかし，メソッドではない）
   有効なセレクタ式である場合，
   `x.f` は `(*x).f` の省略形である．
4. 他のすべての場合で，`x.f` は不正である．
5. `x` がポインタ型であり，値 `nil` を持ち，
   `x.f` が構造体フィールドを表すとき，
   `x.f` への代入や，`x.f` の評価は
[ランタイムパニック](#ランタイムパニック)が発生する．
6. `x` がインターフェース型であり，値 `nil` を持つとき，
メソッド `x.f` の呼び出しや `x.f` の評価は，
[ランタイムパニック](#ランタイムパニック)が発生する．

例えば，以下の宣言が与えられたとき：

```go
type T0 struct {
	x int
}

func (*T0) M0()

type T1 struct {
	y int
}

func (T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (*T2) M2()

type Q *T2

var t T2     // t.T0 != nil とする
var p *T2    // p != nil であり，(*p).T0 != nil とする
var q Q = p
```

次のように書ける．

```go
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        (*q).x は有効なフィールドセレクタである

p.M0()       // ((*p).T0).M0()      M0 は *T0 レシーバーを想定する
p.M1()       // ((*p).T1).M1()      M1 は T1 レシーバーを想定する
p.M2()       // p.M2()              M2 は *T2 レシーバーを想定する
t.M2()       // (&t).M2()           M2 は *T2 レシーバーを想定する, 呼び出し節を参照
```

しかし，以下は無効である．

```go
q.M0()       // (*q).M0 は有効であるが，フィールドセレクタである
```

## メソッド式

`M` が型 `T` の[メソッド集合](#メソッド集合)に存在する場合，
`T.M` は
`M` の引数の最初に，
メソッドのレシーバーを追加したものを引数として，
通常の関数のように呼び出し可能である関数である．

```
MethodExpr    = ReceiverType "." MethodName .
ReceiverType  = Type .
```

構造体型 `T` が 2 つのメソッド `Mv`, `Mp` をもつとする．
`Mv` のレシーバーは型 `T` である．
`Mp` のレシーバーは型 `*T` である．

```go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
```

式

```go
T.Mv
```

は， `Mv` と等価であるが，
その最初の引数として明示的なレシーバーをもつ
関数を生成する (yield)．
それは次のシグネチャをもつ．

```go
func(tv T, a int) int
```

その関数は，明示的なレシーバーで通常呼び出されるため，
以下の 5 つの呼び出し方法は等価である．

```go
t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)
```

同様に，式

```go
(*T).Mp
```

は，次のシグネチャをもつ `Mp` を表現する関数値を生成する．

```go
func(tp *T, f float32) float32
```

値レシーバをもつメソッドの場合，
明示的なポインターレシーバーをもつ関数を導出する．

```go
(*T).Mv
```

は，次のシグネチャをもつ `Mv` を表現する関数値を生成する．

```go
func(tv *T, a int) int
```

そのような関数は，@@@
メソッドは，関数呼び出しで渡されるアドレスの値を上書きしない．

最後のケースである，
ポインターレシーバーメソッドのための値レシーバー関数は，
ポインターレシーバーメソッドは値型のメソッド集合に属しないので，
不正である．

メソッドから派生した関数値は
関数呼び出し構文で呼び出される．
レシーバーは，最初の引数として提供される．
つまり，`f := T.Mv` が与えられたとき，
`f` は `t.f(7)` ではなく，`f(t, 7)` のように呼び出される．
レシーバーをバインドする関数の構築には，
[関数リテラル](#関数リテラル)か[メソッド値](#メソッド値)を使用する．

インターフェース型のメソッドの関数値を派生させることは不正である．
結果となる関数は，インターフェース型の明示的なレシーバをとる．


## メソッド値

式 `x` が静的な型 `T` をもち，
`M` が型 `T` の[メソッド集合](#メソッド集合)に属する場合，
`x.M` は**メソッド値** (method value) と呼ばれる．
メソッド値 `x.M` は
`x.M` のメソッド呼び出しと同じ引数で呼び出される関数値である．
式 `x` は評価され，メソッド値が評価される間保存される．
保存されたコピーは，
あとで実行される可能性のある
任意の呼び出しでレシーバーとして使用される．


型 `T` はインターフェース型，または，非インターフェース型である．

上記[メソッド式](#メソッド式)で説明したように，
2 つのメソッド `Mv` と `Mp` をもつ構造体型 `T` を考える.
`Mv` のレシーバーは型 `T` で，
`Mp` のレシーバーは型 `*T` である．

```go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
var pt *T
func makeT() T
```

式

```go
t.Mv
```

は次の型の関数値を生成する．

```go
func(int) int
```

次の 2 つの呼び出し方法は等価である：

```go
t.Mv(7)
f := t.Mv; f(7)
```

同様に，式

```go
pt.Mp
```

は次の型の関数値を生成する．

```go
func(float32) float32
```

[セレクタ](#セレクタ)と同様に，
ポインターを使って値レシーバーをもつ
非インターフェースメソッドへの参照は，
自動的にそのポインターを間接参照 (dereference) する：
つまり，`pt.Mv` は `(*pt).Mv` と等価である．


[メソッド呼び出し](#呼び出し)と同様に，
アドレス値を使ってポインターレシーバーをもつ
非インターフェースメソッドへの参照は，
自動的にその値をアドレスをとる：
つまり，`t.Mp` は `(&t).Mp` と等価である．


```go
f := t.Mv; f(7)   // t.Mv(7) と同様
f := pt.Mp; f(7)  // pt.Mp(7) と同様
f := pt.Mv; f(7)  // (*pt).Mv(7) と同様
f := t.Mp; f(7)   // (&t).Mp(7) と同様
f := makeT().Mp   // 無効: makeT() の結果はアドレスではない
```

上の例は非インターフェース型を使用しているが，
インターフェース型の値からメソッド値を生成することは正当である．

```go
var i interface { M(int) } = myVal
f := i.M; f(7)  // like i.M(7)
```

## インデックス式


一次式

```go
a[x]
```

は，配列, 配列へのポインター，スライス，文字列，または，マップ `a` の
`x` でインデックスされた要素を示す．
値 `x` はそれぞれ，**インデックス** (index) または**マップキー** (map key) と呼ばれる．
以下のルールが適用される．

`a` がマップでない場合
- インデックス `x` は整数型か型なし定数型でなければならない
- 定数インデックスは非負であり，型 `int` の値として[表現可能](#表現可能性)でなければならない
- 型なしの定数インデックスは型 `int` で与えられる
- インデックス `x` は， `0 <= x < len(a)` であれば，**範囲内** (in range)であり，
それ以外の場合は**範囲外** (out of range)である．

`a` が[配列型](#配列型) `A` の場合

- [定数](#定数)インデックスは範囲内でなければならない
- 実行時に `x` が範囲外である場合，
[ランタイムパニック](#ランタイムパニック)が発生する．
- `a[x]` はインデックス `x` の配列要素であり，
`a[x]` の型は `A` の要素型である．

`a` が配列型への[ポインター](#ポインター型)の場合，
- `a[x]` は `(*a)[x]` の省略形である．

`a` が[スライス型](#スライス型) `S` の場合
- 実行時に `x` が範囲外である場合，
[ランタイムパニック](#ランタイムパニック)が発生する．
- `a[x]` はインデックス `x` のスライス要素であり，`a[x]` の型は `S` の要素型である．

`a` が[文字列型](#文字列型)の場合
- 文字列 `a` もまた定数の場合，[定数](#定数)インデックスは範囲内でなければならない．
- 実行時に `x` が範囲外である場合，
[ランタイムパニック](#ランタイムパニック)が発生する．
- `a[x]` はインデックス `x` の非定数バイト値であり，`a[x]` の型は `byte` である．
- `a[x]` へは代入できない場合がある

`a` が[マップ型](#マップ型) `M` の場合
- `x` の型は `M` のキー型へ[代入可能](#代入可能性)でなければならない
- マップはキー `x` のエントリーを含む場合，
`a[x]` はキー `x` のマップ要素であり，
`a[x]` の型は `M` の要素型である．
- マップが `nil` であるか，エントリーを持たない場合，
`a[x]` は `M` の要素型の[ゼロ値](#ゼロ値)である．

上記以外の場合，`a[x]` は不正である．

[代入](#代入)や初期化で使用される
型 `map[K]V` のマップ `a` のインデックス式

```go
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]
```

は，追加の型なし真偽値を生成する．
キー `x` がマップに存在するなら，
`ok` の値は `true` であり，
存在しないなら，`false` である．

`nil` 要素の代入は[ランタイムパニック](#ランタイムパニック)が発生する．

## スライス式

スライス式 (slice expression) は
文字列，配列，配列へのポインター，または，スライスから
部分文字列，または，スライスを構築する．
2 つのバリアント (variant) がある：
下限と上限を指定する単純な形式 (simple form) と，
容量の上限も指定する完全な形式 (full form) である．

### 単純なスライス式

文字列，配列，配列へのポインター，または，スライスに対する
一次式

```go
a[low : high]
```

は，部分文字列かスライスを構築する．
**インデックス** `low` と `high` は
オペランド `a` の要素が復帰値に現れる選択する@@@．
復帰値は，0 から始まり，長さ `high - low` のインデックスを持つ．
配列 `a` をスライスすると，

```go
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
```

スライス `s` は型 `[]int`，長さ 3，容量 4 であり，
次の要素をもつ．

```go
s[0] == 2
s[1] == 3
s[2] == 4
```

利便性のため，いずれのインデックスも省略できる．
`low` インデックスがない場合は `0`，
`high` インデックスがない場合は，スライスされたオペランドの長さとなる．

```go
a[2:]  // a[2 : len(a)] と同じ
a[:3]  // a[0 : 3] と同じ
a[:]   // a[0 : len(a)] と同じ
```

`a` が配列へのポインターである場合，
`a[low : high]` は `(*a)[low : high]` の省略形である．

配列か文字列の場合，
インデックスは，
`0 <= low <= high <= len(a)` であれば，**範囲内** (in range) であり，
そうでなければ，**範囲外** (out of range) である．
スライスに対して，
インデックスの場合，
長さではなく，スライスの容量 `cap(a)` である．
[定数](#定数)インデックスは，非負で，型 `int` で[表現可能](#表現可能性)でなければならない．
配列か定数文字列の場合，
定数インデックは範囲内でなければならない．
どちらのインデックスも定数であるなら， `low <= high` を満足しなければならない．
実行時にインデックスが範囲外であれば，
[ランタイムパニック](#ランタイムパニック)が発生する．

[型なし文字列](#定数)を除いて，
スライスされたオペランドが，文字列かスライスの場合，
スライス演算の復帰は，オペランドとして同じ型の非定数値である．
型なし文字列オペランドの場合，
復帰は，型 `string` の非定数値である．
スライスオペランド (sliced operand) が配列の場合，
それは[アドレス可能](#アドレス演算子)でなければならず，
スライス演算の復帰は，
配列として同じ要素型をもつスライスである．


有効なスライス式のスライスオペランドが `nil` スライスである場合，
復帰は `nil` スライスである．
そうでなければ，復帰がスライスであれば，
それは，基底配列とオペランドを共有する．


```go
var a [10]int
s1 := a[3:7]   // s1 の基底配列は配列 a; &s1[2] == &a[5]
s2 := s1[1:4]  // s2 の基底配列は s1 の基底配列である配列 a; &s2[1] == &a[5]
s2[1] = 42     // s2[1] == s1[2] == a[5] == 42; すべて，同じ基底配列の要素を参照する
```

### 完全なスライス式

配列，配列へのポインター，スライス `a` (文字列ではない）に対して，
一次式

```go
a[low : high : max]
```

は，同じ型で
単純なスライス表現 `a[low : high]` と同じ長さと要素を持つ
スライスを構築する．
さらに，
復帰されるスライスの容量
最初のインデックスのみ省略でき，その値は 0 になる．
配列 `a` をスライスすると，

```go
a := [5]int{1, 2, 3, 4, 5}
t := a[1:3:5]
```

スライス `t` は型 `[]int`，長さ 2，容量 4 を持ち，要素は以下を満たす．

```go
t[0] == 2
t[1] == 3
```

単純なスライス表現のように，
`a` が配列へのポインターのとき，
`a[low : high : max]` は，
`(*a)[low : high : max]` の省略形である．
スライスオペランドが配列であれば，それは，
[アドレス可能](#アドレス演算子)でなければならない．


インデックは `0 <= low <= high <= max <= cap(a)` のとき，
**範囲内** であり，そうでなければ，**範囲外** である．
[定数](#定数)インデックスは，非負で，型 `int` で[表現可能](#表現可能性)でなければならない．
配列の場合，
定数インデックスは，範囲内でなければならない．
複数のインデックスが定数の場合，
定数は相対的な範囲内になければならない．
実行時にインデックスが範囲外の場合，
[ランタイムパニック](#ランタイムパニック)が発生する．


## 型アサーション

[インターフェース型](#インターフェース型)の式 `x` と
型 `T` に対して，一次式

```go
x.(T)
```

は，`x` は `nil` ではなく，`x` に格納された値が型 `T` であることを主張する (assert)．
表記 `x.(T)` は**型アサーション** (type assertion) と呼ばれる．


より正確には，
`T` がインターフェース型でない場合，
`x.(T)` は `x` の動的な型が型 `T` と[同一](#型の一意性)であることを主張する．
このケースでは，
`T` は `x` の（インターフェース）型を[実装](#メソッド集合)しなければならない．
そうでなければ，
`x` に型 `T` の値を格納できないので，
型アサーションは無効となる．
`T` がインターフェース型であれば，
`x.(T)` は `x` の動的な型がインターフェース `T` を実装することを主張する．

型アサーションが成り立つとき，
式の値は，
`x` に格納した値であり，
その型は `T` である．
もし，型アサーションが `false` であれば，
[ランタイムパニック](#ランタイムパニック)が発生する． (@@@おかしい@@@）
言い換えると，
実行時に `x` の動的な型を知ることができるが，
`x.(T)` の型は正しいプログラムではわかっている．

```go
var x interface{} = 7          // x は動的な型 int を持ち，値 7 である
i := x.(int)                   // i は型 int を持ち，値 7

type I interface { m() }

func f(y I) {
	s := y.(string)        // 不正: string は I を実装しない (メソッド m がない)
	r := y.(io.Reader)     // r は型 io.Reader を持ち， y の動的な型は I と io.Reader の両方を実装しなければならない
	…
}
```

[代入](#代入)や初期化で使用される
型アサーション

```go
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
var v, ok T1 = x.(T)
```

は，追加の型なし真偽値を生成する．
アサーションが成り立つなら，
`ok` の値は `true` であり，
存在しないなら，`false` であり，
`v` の値は型 `T` の[ゼロ値](#ゼロ値)になる．
このケースでは，[ランタイムパニック](#ランタイムパニック)は発生しない．

## 呼び出し

関数型 `F` の式 `f` が与えられたとき，


```go
f(a1, a2, … an)
```

は引数 `a1, a2, … an` で `f` を呼び出す．
特別な場合を除いて，
引数は `F` のパラメータ型 (parameter type) に代入可能な単一の値をもつ式でなければならず，
関数が呼び出される前に評価される．
その式の型は，`F` の復帰型 (return type) である．
メソッド呼び出しは似ているが，
メソッドはそれ自身が，
メソッドのレシーバー型の値の
セレクタとして指定される．


```go
math.Atan2(x, y)  // 関数呼び出し
var pt *Point
pt.Scale(3.5)     // レシーバー pt を用いたメソッド呼び出し
```

関数呼び出しでは，
関数値と引数は，[通常の順序](#評価順序)で評価される．
それらが評価されたあと，
その呼び出しのパラメーターは，
関数の値として渡され，
呼び出された関数は実行を開始する．
関数が復帰するとき，
関数の復帰パラメータは，
呼び出し元に値が渡される．

`nil` 関数値の呼び出しは，
[ランタイムパニック](#ランタイムパニック)が発生する．

特別な場合として，
関数 `g` またはメソッド `g` の復帰値が，
他の関数 `f` またはメソッド `f` のパラメータに
数が等しく，個別に代入可能なとき，
呼び出し `f(g(g のパラメータ))` は
`f` のパラメータに `g` の復帰値を順番にバインドした後に実行される．
`f` の呼び出しは `g` の呼び出し以外のパラメータを含んではならないし，
`g` は少なくとも 1 つの復帰値を持たなければならない．
`f` が最後に `...` パラメータを持つ場合，
通常のパラメータの代入後に残った `g` の復帰値が代入される．


```go
func Split(s string, pos int) (string, string) {
	return s[0:pos], s[pos:]
}

func Join(s, t string) string {
	return s + t
}

if Join(Split(value, len(value)/2)) != value {
	log.Panic("test fails")
}
```

`x` の（型の）
[メソッド集合](#メソッド集合) が `m` を含み，
引数リストに `m` のパラメータリストが代入可能なら，
メソッド呼び出し `x.m()` は有効である．
`f` が[アドレス可能](#アドレス演算) であり，
`&x` のメソッド集合が, `m` を含むとき，
`x.m()` は `(&x).m()` の省略形である．

```go
var p Point
p.Scale(3.5)
```

別のメソッド型やメソッドリテラルはない．

## 引数に `...` パラメータを渡す

`f` が
型 `...T` の最後のパラメータ `p` をもつ[可変長引数](#関数型) (variadic) な場合
`f` 内では，
`p` の型は，型 `[]T` と等価である．
`f` が，`p` の実際の引数なしで実行された場合，
`p` に渡される値は，`nil` である．
そうでなければ，
その渡された値は
連続する要素が実際の引数 (すべて `T` に[代入可能](#代入可能性)でなければならない) である
新しい基底配列にもつ
型 `[]T` の新しいスライスである．
そのため，
スライスの長さと容量は `p` にバインドされる引数の数であり，
呼び出し位置毎に異なる場合がある．


次の関数と呼び出しを考えると，

```go
func Greeting(prefix string, who ...string)
Greeting("nobody")
Greeting("hello:", "Joe", "Anna", "Eileen")
```

`Greeting` 内では，
最初の呼び出しでは， `who` は `nil` であり，
次の呼び出しでは，`who` は `[]string{"Joe", "Anna", "Eileen"}` である．

最後の引数は，スライス型 `[]T` に代入可能である場合，
引数の後に `...` を続けると，
`...T` パラメータの値がそのまま渡される．
このケースでは，新しいスライスは生成されない．


次のスライス `s` と呼び出しを考えると，

```go
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)
```

`Greeting` 内では，
`s` と同じ基底配列の値をもつ．

## 演算子

演算子 (operator) は，オペランドを式に結合する．

```
Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
```

比較については，[別の場所](#比較演算子)で説明する．
他の二項演算子の場合，
演算子がシフトか型なし[定数](#定数)の場合を除いて
オペランド型は[同一](#型の一意性)でなければならない．
定数のみの演算の場合は，[定数式](#定数式)節を参照されたい．

シフト演算を除いて，
一方のオペランドが型なし[定数](#定数)で，
他方のオペランドがそうでない場合，
定数は他方のオペランドの型に暗黙的に[変換](#変換)される．

シフト式における右のオペランドは，
整数型であるか，型 `uint` の値で[表現可能](#表現可能性)な型なし定数でなければならない．
非定数シフト式の左のオペランドが型なし定数の場合，
最初に暗黙的に
シフト式が左のオペランドに置き換えられた場合に想定される型に
変換される．


```go
var s uint = 33
var i = 1<<s                  // 1 は型 int をもつ
var j int32 = 1<<s            // 1 は型 int32 をもつ; j == 0
var k = uint64(1<<s)          // 1 は型 uint64 をもつ; k == 1<<33
var m int = 1.0<<s            // 1.0 は型 int をもつ; 型なし int が 32bit の場合 m == 0
var n = 1.0<<s == j           // 1.0 は型 int32 をもつ; n == true
var o = 1<<s == 2<<s          // 1 と 2 は型 type int をもつ; 型なし int が 32bit の場合 o == true
var p = 1<<s == 1<<33         // int が 32bit の場合は不正: 1 は型 int をもつが，1<<33 はオーバーフローする
var u = 1.0<<s                // 不正: 1.0 は型 float64, シフトできない
var u1 = 1.0<<s != 0          // 不正: 1.0 は型 float64, シフトできない
var u2 = 1<<s != 1.0          // 不正: 1 は型 float64, シフトできない
var v float32 = 1<<s          // 不正: 1 は型 float32, シフトできない
var w int64 = 1.0<<33         // 1.0<<33 は定数シフト式
var x = a[1.0<<s]             // 1.0 は型 int; 型なし int が 32bit の場合 x == a[0]
var a = make([]byte, 1.0<<s)  // 1.0 は型 int; 型なし int が 32bit の場合 len(a) == 0
```

### 演算子の優先順位

単項演算子は最も高い優先順位をもつ．
`++` 演算子と `--` 演算子は
式 (expression) ではなく，文 (statement) を形成する
これらは，オペレータの階層の外である．
結果として，文 `*p++` は `(*p)++` と同じになる．

二項演算子には 5 つの優先順位がある．
乗算演算子 `mul_op` が最も強く，
加算演算子 `add_op`，
比較演算子 `rel_op`，
論理積 `&&`，
最後に，論理和 `||` が続く：

```
優先順位          演算子
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
```

同じ優先順位の二項演算子は，
左から右に関連付けられる．(訳注：左結合性)
例えば，
`x / y * z` は
`(x / y) * z` と同じである．

```go
+x
23 + 3*x[i]
x <= f()
^a >> b
f() || g()
x == y+1 && <-chanPtr > 0
```

## 算術演算子

算術演算子 (arithmetic operator) は，
数値に対して適用し，
最初のオペランドと同じ型の結果を生成する．
4 つの標準算術演算子 (`+`, `-`, `*`, `/`) は，
整数型，浮動小数点型，複素数型に適用する．
`+` 演算子は文字列にも適用する．
ビット単位論理演算子とシフト演算子は整数のみに適用する．


```
+    和                     整数, 浮動小数点, 複素数値, 文字列
-    差                     整数, 浮動小数点, 複素数値
*    積                     整数, 浮動小数点, 複素数値
/    商                     整数, 浮動小数点, 複素数値
%    剰余                   整数

&    ビット単位 AND         整数
|    ビット単位 OR          整数
^    ビット単位 XOR         整数
&^   ビットクリア (AND NOT) 整数

<<   算術左シフト           整数 << 符号なし整数
>>   算術左シフト           整数 >> 符号なし整数
```


訳注：ビットクリアは，ビット単位 AND (論理積) のNOT (否定) を計算する．

### 整数演算子

2 つの整数値 `x` と `y` に対し，
整数商 (quotient) `q = x / y` と剰余 (remainder) `r = x % y` は
次の関係を満足する．

```go
x = q*y + r  かつ  |r| < |y|
```

ここで，`x / y` はゼロに向かって切り捨てられる
(["端数処理"](https://ja.wikipedia.org/wiki/%E5%89%B0%E4%BD%99%E6%BC%94%E7%AE%97))．

```
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
```

この規則の 1 つの例外は，
被除数 `x` は `x` の `int` 型における最も小さな値である (most negative value) とき，
2 の補数の[整数オーバーフロー](#整数オーバーフロー) のため，
商 `q = x / -1` は，`x` と等しく，
剰余 `r = 0` である．

```
			 x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
```

除数が[定数](#定数) の場合，0 であってはならない．
実行時に除数が 0 であると，
[ランタイムパニック](#ランタイムパニック) (run-time panic) が発生する．
被除数が非負で，除数が定数の 2 の冪乗である場合，
算術右シフトに置き換えられ
剰余計算は，ビット単位論理積に置き換えられることがある．


```
 x     x / 4     x % 4     x >> 2     x & 3
 11      2         3         2          3
-11     -2        -3        -3          1
```

シフト演算 (shift operator) は，右のオペランドで指定される
シフトカウント (shift count) によって，左のオペランドがシフトされる．
そのため，左のオペランドは非負でなければならない．
実行時にシフトカウントが負の場合，
[ランタイムパニック](#ランタイムパニック) (run-time panic) が発生する．
シフト演算子は，
左のオペランドが符号付き整数の場合，算術シフト (arithmetic shift) を，
左のオペランドが符号なし整数の場合，論理シフト (logical shift) を実装する．
シフトカウントの上限はない．
シフトは，左のオペランドが
シフトカウント `n` に対して，
`n` 回 1 シフトされるように動作する．
結果として，`x << 1` は `x * 2` と同じであり，
`x >> 1` は
負の無限大に向かって切り捨てられるが，
`x / 2` と同じである．

整数オペランドに対して，
単項演算 `+`, `-`, `^` は以下のように定義される．

```
+x                          は 0 + x
-x    符号反転              は 0 - x
^x    ビット単位補完        は m ^ x  で， m はすべてのビットに 1 をセットしたもの (符号なし x の場合)
                                           m = -1  (符号付き x の場合)
```

### 整数オーバーフロー

符号なし整数に対して，
演算子 `+`, `-`, `*`, `<<` は，
`2^n` を法として計算される．
ここで，`n` は[符号なし整数](#数値型)型のビット幅である．
大まかに言うと，
これら符号なし整数の演算は，
オーバーフロー (overflow) した上位ビットを捨て，
プログラムは，「ラップアラウンド」 (wrap arround) に依存することがある．

訳注： ラップアラウンドは，処理可能な範囲の最後に達した後に，最初に戻ること．
例えば，`uint8` 型の `0xff`, `0x01` に対して， `0xff + 0x01` が `0x00` になる．


符号付き整数に対して，
演算子 `+`, `-`, `*`, `<<` は，
正当にオーバーフローし，
復帰値は存在し，
復帰値は，
符号付き整数の表現，演算子，そのオペランドによって決定的に定義される．
オーバーフローによる
[ランタイムパニック](#ランタイムパニック) (run-time panic) は発生しない．
コンパイラは，
オーバーフローが発生しないことを仮定した
コードの最適化は行わない場合がある．
例えば，`x < x + 1` はいつでも `true` とは限らない．

### 浮動小数点演算子

浮動小数点数と複素数に対して，
`+x` は `x` と同じであるが，
`-x` は `x` の符号反転 (negation) である．
浮動小数点か複素数をゼロで割った復帰値は
IEEE-754 標準で指定されていない．
[ランタイムパニック](#ランタイムパニック) (run-time panic) が発生するかどうかは，実装依存である．

実装では，
複数の浮動小数点数演算を
（場合によっては，文を超えて）
単一の融合演算 (fused operation) に結合し，
命令を個別に実行および丸めて得られる値と異なる結果を生成する場合がある．
明示的な浮動小数点型への[変換](#変換)は，
変換先の型の精度へ丸める．
これは，その丸めを破棄する融合を防ぐ．

例えば，一部のアーキテクチャでは，
`x * y + z` の中間結果 `x * y` を丸めずに計算する
「融合積和演算 (fused multiply and add; FMA)」命令を提供する．
次の例は，Go 実装がその命令を使用できるか示している：

```go
// FMA は r の計算を許す．なぜなら， x*y は明示的な丸めがないから
r  = x*y + z
r  = z;   r += x*y
t  = x*y; r = t + z
*p = x*y; r = *p + z
r  = x*y + float64(z)

// FMA は r の計算を許さない．なぜなら，x*y の丸めを省略するから
r  = float64(x*y) + z
r  = z; r += float64(x*y)
t  = float64(x*y); r = t + z
```

### 文字列の連結

文字列 (string) は，`+` 演算子か `+=` 代入演算子を使って連結 (concatenate) できる．

```go
s := "hi" + string(c)
s += " and good bye"
```

文字列の追加は，
オペランドの連結によって新しい文字列が生成される．

